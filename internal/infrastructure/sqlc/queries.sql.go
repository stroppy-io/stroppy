// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const GetAllResourcesIps = `-- name: GetAllResourcesIps :many
SELECT DISTINCT (ni ->> 'ip_address')::TEXT AS ip_address
FROM cloud_resources
         CROSS JOIN LATERAL jsonb_array_elements(
        resource_def -> 'spec' -> 'yandexCloudVm' -> 'networkInterface'
                            ) AS ni
WHERE ni ? 'ip_address'
  AND ni ->> 'ip_address' IS NOT NULL
  AND ni ->> 'ip_address' <> ''
AND status = ANY($1::int[])
`

func (q *Queries) GetAllResourcesIps(ctx context.Context, dollar_1 []int32) ([]string, error) {
	rows, err := q.db.Query(ctx, GetAllResourcesIps, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var ip_address string
		if err := rows.Scan(&ip_address); err != nil {
			return nil, err
		}
		items = append(items, ip_address)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetResourceTree = `-- name: GetResourceTree :many
WITH RECURSIVE tree AS (
    SELECT id, created_at, updated_at, deleted_at, status, ref, resource_def, resource_yaml, synced, ready, external_id, parent_resource_id
    FROM cloud_resources
    WHERE cloud_resources.id = $1

    UNION ALL

    SELECT c.id, c.created_at, c.updated_at, c.deleted_at, c.status, c.ref, c.resource_def, c.resource_yaml, c.synced, c.ready, c.external_id, c.parent_resource_id
    FROM cloud_resources c
             INNER JOIN tree t ON c.parent_resource_id = t.id
)
SELECT id, created_at, updated_at, deleted_at, status, ref, resource_def, resource_yaml, synced, ready, external_id, parent_resource_id
FROM tree
`

type GetResourceTreeRow struct {
	ID               string             `db:"id"`
	CreatedAt        pgtype.Timestamptz `db:"created_at"`
	UpdatedAt        pgtype.Timestamptz `db:"updated_at"`
	DeletedAt        pgtype.Timestamptz `db:"deleted_at"`
	Status           int32              `db:"status"`
	Ref              []byte             `db:"ref"`
	ResourceDef      []byte             `db:"resource_def"`
	ResourceYaml     string             `db:"resource_yaml"`
	Synced           bool               `db:"synced"`
	Ready            bool               `db:"ready"`
	ExternalID       string             `db:"external_id"`
	ParentResourceID *string            `db:"parent_resource_id"`
}

func (q *Queries) GetResourceTree(ctx context.Context, id string) ([]*GetResourceTreeRow, error) {
	rows, err := q.db.Query(ctx, GetResourceTree, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetResourceTreeRow
	for rows.Next() {
		var i GetResourceTreeRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Status,
			&i.Ref,
			&i.ResourceDef,
			&i.ResourceYaml,
			&i.Synced,
			&i.Ready,
			&i.ExternalID,
			&i.ParentResourceID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetResourceTreeByStatuses = `-- name: GetResourceTreeByStatuses :many
WITH RECURSIVE tree AS (
    SELECT id, created_at, updated_at, deleted_at, status, ref, resource_def, resource_yaml, synced, ready, external_id, parent_resource_id
    FROM cloud_resources
    WHERE cloud_resources.id = $1 AND cloud_resources.status = ANY($2::int[])

    UNION ALL

    SELECT c.id, c.created_at, c.updated_at, c.deleted_at, c.status, c.ref, c.resource_def, c.resource_yaml, c.synced, c.ready, c.external_id, c.parent_resource_id
    FROM cloud_resources c
             INNER JOIN tree t ON c.parent_resource_id = t.id
)
SELECT id, created_at, updated_at, deleted_at, status, ref, resource_def, resource_yaml, synced, ready, external_id, parent_resource_id
FROM tree
`

type GetResourceTreeByStatusesParams struct {
	ID      string  `db:"id"`
	Column2 []int32 `db:"column_2"`
}

type GetResourceTreeByStatusesRow struct {
	ID               string             `db:"id"`
	CreatedAt        pgtype.Timestamptz `db:"created_at"`
	UpdatedAt        pgtype.Timestamptz `db:"updated_at"`
	DeletedAt        pgtype.Timestamptz `db:"deleted_at"`
	Status           int32              `db:"status"`
	Ref              []byte             `db:"ref"`
	ResourceDef      []byte             `db:"resource_def"`
	ResourceYaml     string             `db:"resource_yaml"`
	Synced           bool               `db:"synced"`
	Ready            bool               `db:"ready"`
	ExternalID       string             `db:"external_id"`
	ParentResourceID *string            `db:"parent_resource_id"`
}

func (q *Queries) GetResourceTreeByStatuses(ctx context.Context, arg *GetResourceTreeByStatusesParams) ([]*GetResourceTreeByStatusesRow, error) {
	rows, err := q.db.Query(ctx, GetResourceTreeByStatuses, arg.ID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetResourceTreeByStatusesRow
	for rows.Next() {
		var i GetResourceTreeByStatusesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Status,
			&i.Ref,
			&i.ResourceDef,
			&i.ResourceYaml,
			&i.Synced,
			&i.Ready,
			&i.ExternalID,
			&i.ParentResourceID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
