// @generated by protoc-gen-es v2.10.1 with parameter "json_types=true,valid_types=legacy_required+protovalidate_required,target=ts,import_extension=ts"
// @generated from file proto/stroppy/common.proto (package stroppy, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import { file_validate_validate } from "../../validate/validate_pb.ts";
import type { Timestamp, TimestampJson } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file proto/stroppy/common.proto.
 */
export const file_proto_stroppy_common: GenFile = /*@__PURE__*/
  fileDesc("Chpwcm90by9zdHJvcHB5L2NvbW1vbi5wcm90bxIHc3Ryb3BweSLsAgoKT3RscEV4cG9ydBIfChJvdGxwX2dycGNfZW5kcG9pbnQYASABKAlIAIgBARIfChJvdGxwX2h0dHBfZW5kcG9pbnQYAyABKAlIAYgBARIoChtvdGxwX2h0dHBfZXhwb3J0ZXJfdXJsX3BhdGgYBCABKAlIAogBARIjChZvdGxwX2VuZHBvaW50X2luc2VjdXJlGAUgASgISAOIAQESGQoMb3RscF9oZWFkZXJzGAYgASgJSASIAQESIAoTb3RscF9tZXRyaWNzX3ByZWZpeBgCIAEoCUgFiAEBQhUKE19vdGxwX2dycGNfZW5kcG9pbnRCFQoTX290bHBfaHR0cF9lbmRwb2ludEIeChxfb3RscF9odHRwX2V4cG9ydGVyX3VybF9wYXRoQhkKF19vdGxwX2VuZHBvaW50X2luc2VjdXJlQg8KDV9vdGxwX2hlYWRlcnNCFgoUX290bHBfbWV0cmljc19wcmVmaXgiIQoHRGVjaW1hbBIWCgV2YWx1ZRgBIAEoCUIH+kIEcgIQASIfCgRVdWlkEhcKBXZhbHVlGAEgASgJQgj6QgVyA7ABASI1CghEYXRlVGltZRIpCgV2YWx1ZRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAiHwoEVWxpZBIXCgV2YWx1ZRgBIAEoCUII+kIFcgOYARoi+QMKBVZhbHVlEigKBG51bGwYASABKA4yGC5zdHJvcHB5LlZhbHVlLk51bGxWYWx1ZUgAEg8KBWludDMyGAIgASgFSAASEAoGdWludDMyGAMgASgNSAASDwoFaW50NjQYBCABKANIABIQCgZ1aW50NjQYBSABKARIABIPCgVmbG9hdBgGIAEoAkgAEhAKBmRvdWJsZRgHIAEoAUgAEhAKBnN0cmluZxgIIAEoCUgAEg4KBGJvb2wYCSABKAhIABIjCgdkZWNpbWFsGAogASgLMhAuc3Ryb3BweS5EZWNpbWFsSAASHQoEdXVpZBgLIAEoCzINLnN0cm9wcHkuVXVpZEgAEiUKCGRhdGV0aW1lGAwgASgLMhEuc3Ryb3BweS5EYXRlVGltZUgAEicKBnN0cnVjdBgNIAEoCzIVLnN0cm9wcHkuVmFsdWUuU3RydWN0SAASIwoEbGlzdBgOIAEoCzITLnN0cm9wcHkuVmFsdWUuTGlzdEgAEgsKA2tleRhlIAEoCRomCgRMaXN0Eh4KBnZhbHVlcxgBIAMoCzIOLnN0cm9wcHkuVmFsdWUaKAoGU3RydWN0Eh4KBmZpZWxkcxgBIAMoCzIOLnN0cm9wcHkuVmFsdWUiGwoJTnVsbFZhbHVlEg4KCk5VTExfVkFMVUUQAEIGCgR0eXBlIrcSCgpHZW5lcmF0aW9uGk0KCEFscGhhYmV0EkEKBnJhbmdlcxgBIAMoCzIgLnN0cm9wcHkuR2VuZXJhdGlvbi5SYW5nZS5VSW50MzJCD/pCDJIBCQgBIgWKAQIQARqvAQoMRGlzdHJpYnV0aW9uEkkKBHR5cGUYASABKA4yMS5zdHJvcHB5LkdlbmVyYXRpb24uRGlzdHJpYnV0aW9uLkRpc3RyaWJ1dGlvblR5cGVCCPpCBYIBAhABEh0KBXNjcmV3GAIgASgBQg76QgsSCSkAAAAAAAAAACI1ChBEaXN0cmlidXRpb25UeXBlEgoKBk5PUk1BTBAAEgsKB1VOSUZPUk0QARIICgRaSVBGEAIajggKBVJhbmdlGhUKBEJvb2wSDQoFcmF0aW8YASABKAIafQoGU3RyaW5nEjMKCGFscGhhYmV0GAEgASgLMhwuc3Ryb3BweS5HZW5lcmF0aW9uLkFscGhhYmV0SACIAQESFAoHbWluX2xlbhgCIAEoBEgBiAEBEg8KB21heF9sZW4YAyABKARCCwoJX2FscGhhYmV0QgoKCF9taW5fbGVuGiUKCUFueVN0cmluZxILCgNtaW4YASABKAkSCwoDbWF4GAIgASgJGi4KBUZsb2F0EhAKA21pbhgBIAEoAkgAiAEBEgsKA21heBgCIAEoAkIGCgRfbWluGi8KBkRvdWJsZRIQCgNtaW4YASABKAFIAIgBARILCgNtYXgYAiABKAFCBgoEX21pbhouCgVJbnQzMhIQCgNtaW4YASABKAVIAIgBARILCgNtYXgYAiABKAVCBgoEX21pbhouCgVJbnQ2NBIQCgNtaW4YASABKANIAIgBARILCgNtYXgYAiABKANCBgoEX21pbhovCgZVSW50MzISEAoDbWluGAEgASgNSACIAQESCwoDbWF4GAIgASgNQgYKBF9taW4aLwoGVUludDY0EhAKA21pbhgBIAEoBEgAiAEBEgsKA21heBgCIAEoBEIGCgRfbWluGrgBCgxEZWNpbWFsUmFuZ2USMAoFZmxvYXQYAiABKAsyHy5zdHJvcHB5LkdlbmVyYXRpb24uUmFuZ2UuRmxvYXRIABIyCgZkb3VibGUYAyABKAsyIC5zdHJvcHB5LkdlbmVyYXRpb24uUmFuZ2UuRG91YmxlSAASNQoGc3RyaW5nGAQgASgLMiMuc3Ryb3BweS5HZW5lcmF0aW9uLlJhbmdlLkFueVN0cmluZ0gAQgsKBHR5cGUSA/hCARrpAgoIRGF0ZVRpbWUSNQoGc3RyaW5nGAIgASgLMiMuc3Ryb3BweS5HZW5lcmF0aW9uLlJhbmdlLkFueVN0cmluZ0gAEkYKDHRpbWVzdGFtcF9wYhgDIAEoCzIuLnN0cm9wcHkuR2VuZXJhdGlvbi5SYW5nZS5EYXRlVGltZS5UaW1lc3RhbXBQYkgAEkUKCXRpbWVzdGFtcBgEIAEoCzIwLnN0cm9wcHkuR2VuZXJhdGlvbi5SYW5nZS5EYXRlVGltZS5UaW1lc3RhbXBVbml4SAAaXwoLVGltZXN0YW1wUGISJwoDbWluGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBInCgNtYXgYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wGikKDVRpbWVzdGFtcFVuaXgSCwoDbWluGAEgASgNEgsKA21heBgCIAEoDUILCgR0eXBlEgP4QgEalggKBFJ1bGUSNgoLaW50MzJfcmFuZ2UYASABKAsyHy5zdHJvcHB5LkdlbmVyYXRpb24uUmFuZ2UuSW50MzJIABI2CgtpbnQ2NF9yYW5nZRgCIAEoCzIfLnN0cm9wcHkuR2VuZXJhdGlvbi5SYW5nZS5JbnQ2NEgAEjgKDHVpbnQzMl9yYW5nZRgDIAEoCzIgLnN0cm9wcHkuR2VuZXJhdGlvbi5SYW5nZS5VSW50MzJIABI4Cgx1aW50NjRfcmFuZ2UYBCABKAsyIC5zdHJvcHB5LkdlbmVyYXRpb24uUmFuZ2UuVUludDY0SAASNgoLZmxvYXRfcmFuZ2UYBSABKAsyHy5zdHJvcHB5LkdlbmVyYXRpb24uUmFuZ2UuRmxvYXRIABI4Cgxkb3VibGVfcmFuZ2UYBiABKAsyIC5zdHJvcHB5LkdlbmVyYXRpb24uUmFuZ2UuRG91YmxlSAASPwoNZGVjaW1hbF9yYW5nZRgHIAEoCzImLnN0cm9wcHkuR2VuZXJhdGlvbi5SYW5nZS5EZWNpbWFsUmFuZ2VIABI4CgxzdHJpbmdfcmFuZ2UYCCABKAsyIC5zdHJvcHB5LkdlbmVyYXRpb24uUmFuZ2UuU3RyaW5nSAASNAoKYm9vbF9yYW5nZRgJIAEoCzIeLnN0cm9wcHkuR2VuZXJhdGlvbi5SYW5nZS5Cb29sSAASPAoOZGF0ZXRpbWVfcmFuZ2UYCiABKAsyIi5zdHJvcHB5LkdlbmVyYXRpb24uUmFuZ2UuRGF0ZVRpbWVIABIVCgtpbnQzMl9jb25zdBgLIAEoBUgAEhUKC2ludDY0X2NvbnN0GAwgASgDSAASFgoMdWludDMyX2NvbnN0GA0gASgNSAASFgoMdWludDY0X2NvbnN0GA4gASgESAASFQoLZmxvYXRfY29uc3QYDyABKAJIABIWCgxkb3VibGVfY29uc3QYECABKAFIABIpCg1kZWNpbWFsX2NvbnN0GBEgASgLMhAuc3Ryb3BweS5EZWNpbWFsSAASFgoMc3RyaW5nX2NvbnN0GBIgASgJSAASFAoKYm9vbF9jb25zdBgTIAEoCEgAEisKDmRhdGV0aW1lX2NvbnN0GBQgASgLMhEuc3Ryb3BweS5EYXRlVGltZUgAEjsKDGRpc3RyaWJ1dGlvbhgeIAEoCzIgLnN0cm9wcHkuR2VuZXJhdGlvbi5EaXN0cmlidXRpb25IAYgBARInCg9udWxsX3BlcmNlbnRhZ2UYHyABKA1CCfpCBioEGGQoAEgCiAEBEhMKBnVuaXF1ZRggIAEoCEgDiAEBQgsKBGtpbmQSA/hCAUIPCg1fZGlzdHJpYnV0aW9uQhIKEF9udWxsX3BlcmNlbnRhZ2VCCQoHX3VuaXF1ZUI4WjZnaXRodWIuY29tL3N0cm9wcHktaW8vc3Ryb3BweS9wa2cvY29tbW9uL3Byb3RvL3N0cm9wcHliBnByb3RvMw", [file_validate_validate, file_google_protobuf_timestamp]);

/**
 * *
 * OtlpExport contains configuration for exporting metrics via OpenTelemetry
 * Protocol (OTLP). It specifies the endpoint and metrics prefix for telemetry
 * data export.
 *
 * @generated from message stroppy.OtlpExport
 */
export type OtlpExport = Message<"stroppy.OtlpExport"> & {
  /**
   * * gRPC endpoint for OpenTelemetry collector 
   *
   * @generated from field: optional string otlp_grpc_endpoint = 1;
   */
  otlpGrpcEndpoint?: string;

  /**
   * * HTTP endpoint for the OpenTelemetry collector 
   *
   * @generated from field: optional string otlp_http_endpoint = 3;
   */
  otlpHttpEndpoint?: string;

  /**
   * * HTTP exporter path. Default is '/v1/metrics' 
   *
   * @generated from field: optional string otlp_http_exporter_url_path = 4;
   */
  otlpHttpExporterUrlPath?: string;

  /**
   * * Disable transport security for the exporter 
   *
   * @generated from field: optional bool otlp_endpoint_insecure = 5;
   */
  otlpEndpointInsecure?: boolean;

  /**
   * * Headers for otlp requests e.g. Authorization=... 
   *
   * @generated from field: optional string otlp_headers = 6;
   */
  otlpHeaders?: string;

  /**
   * * Prefix to be added to all exported metrics 
   *
   * @generated from field: optional string otlp_metrics_prefix = 2;
   */
  otlpMetricsPrefix?: string;
};

/**
 * *
 * OtlpExport contains configuration for exporting metrics via OpenTelemetry
 * Protocol (OTLP). It specifies the endpoint and metrics prefix for telemetry
 * data export.
 *
 * @generated from message stroppy.OtlpExport
 */
export type OtlpExportJson = {
  /**
   * * gRPC endpoint for OpenTelemetry collector 
   *
   * @generated from field: optional string otlp_grpc_endpoint = 1;
   */
  otlpGrpcEndpoint?: string;

  /**
   * * HTTP endpoint for the OpenTelemetry collector 
   *
   * @generated from field: optional string otlp_http_endpoint = 3;
   */
  otlpHttpEndpoint?: string;

  /**
   * * HTTP exporter path. Default is '/v1/metrics' 
   *
   * @generated from field: optional string otlp_http_exporter_url_path = 4;
   */
  otlpHttpExporterUrlPath?: string;

  /**
   * * Disable transport security for the exporter 
   *
   * @generated from field: optional bool otlp_endpoint_insecure = 5;
   */
  otlpEndpointInsecure?: boolean;

  /**
   * * Headers for otlp requests e.g. Authorization=... 
   *
   * @generated from field: optional string otlp_headers = 6;
   */
  otlpHeaders?: string;

  /**
   * * Prefix to be added to all exported metrics 
   *
   * @generated from field: optional string otlp_metrics_prefix = 2;
   */
  otlpMetricsPrefix?: string;
};

export type OtlpExportValid = OtlpExport;

/**
 * Describes the message stroppy.OtlpExport.
 * Use `create(OtlpExportSchema)` to create a new message.
 */
export const OtlpExportSchema: GenMessage<OtlpExport, {jsonType: OtlpExportJson, validType: OtlpExportValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 0);

/**
 * *
 * Decimal represents an arbitrary-precision decimal number.
 *
 * @generated from message stroppy.Decimal
 */
export type Decimal = Message<"stroppy.Decimal"> & {
  /**
   * * String representation of the decimal number 
   *
   * @generated from field: string value = 1;
   */
  value: string;
};

/**
 * *
 * Decimal represents an arbitrary-precision decimal number.
 *
 * @generated from message stroppy.Decimal
 */
export type DecimalJson = {
  /**
   * * String representation of the decimal number 
   *
   * @generated from field: string value = 1;
   */
  value?: string;
};

export type DecimalValid = Decimal;

/**
 * Describes the message stroppy.Decimal.
 * Use `create(DecimalSchema)` to create a new message.
 */
export const DecimalSchema: GenMessage<Decimal, {jsonType: DecimalJson, validType: DecimalValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 1);

/**
 * *
 * Uuid represents a universally unique identifier (UUID).
 *
 * @generated from message stroppy.Uuid
 */
export type Uuid = Message<"stroppy.Uuid"> & {
  /**
   * * String representation of UUID (e.g.,
   * "123e4567-e89b-12d3-a456-426614174000") 
   *
   * @generated from field: string value = 1;
   */
  value: string;
};

/**
 * *
 * Uuid represents a universally unique identifier (UUID).
 *
 * @generated from message stroppy.Uuid
 */
export type UuidJson = {
  /**
   * * String representation of UUID (e.g.,
   * "123e4567-e89b-12d3-a456-426614174000") 
   *
   * @generated from field: string value = 1;
   */
  value?: string;
};

export type UuidValid = Uuid;

/**
 * Describes the message stroppy.Uuid.
 * Use `create(UuidSchema)` to create a new message.
 */
export const UuidSchema: GenMessage<Uuid, {jsonType: UuidJson, validType: UuidValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 2);

/**
 * *
 * DateTime represents a point in time, independent of any time zone or
 * calendar.
 *
 * @generated from message stroppy.DateTime
 */
export type DateTime = Message<"stroppy.DateTime"> & {
  /**
   * * Timestamp in UTC 
   *
   * @generated from field: google.protobuf.Timestamp value = 1;
   */
  value?: Timestamp;
};

/**
 * *
 * DateTime represents a point in time, independent of any time zone or
 * calendar.
 *
 * @generated from message stroppy.DateTime
 */
export type DateTimeJson = {
  /**
   * * Timestamp in UTC 
   *
   * @generated from field: google.protobuf.Timestamp value = 1;
   */
  value?: TimestampJson;
};

export type DateTimeValid = DateTime;

/**
 * Describes the message stroppy.DateTime.
 * Use `create(DateTimeSchema)` to create a new message.
 */
export const DateTimeSchema: GenMessage<DateTime, {jsonType: DateTimeJson, validType: DateTimeValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 3);

/**
 * *
 * Ulid represents a universally universally unique lexicographically sortable identifier (ULID).
 *
 * @generated from message stroppy.Ulid
 */
export type Ulid = Message<"stroppy.Ulid"> & {
  /**
   * * String representation of ULID (e.g., "01ANQWJZ000000000000000000") 
   *
   * @generated from field: string value = 1;
   */
  value: string;
};

/**
 * *
 * Ulid represents a universally universally unique lexicographically sortable identifier (ULID).
 *
 * @generated from message stroppy.Ulid
 */
export type UlidJson = {
  /**
   * * String representation of ULID (e.g., "01ANQWJZ000000000000000000") 
   *
   * @generated from field: string value = 1;
   */
  value?: string;
};

export type UlidValid = Ulid;

/**
 * Describes the message stroppy.Ulid.
 * Use `create(UlidSchema)` to create a new message.
 */
export const UlidSchema: GenMessage<Ulid, {jsonType: UlidJson, validType: UlidValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 4);

/**
 * *
 * Value is a variant type that can represent different types of values.
 * It's used to represent values that can be of multiple types in a type-safe
 * way.
 *
 * @generated from message stroppy.Value
 */
export type Value = Message<"stroppy.Value"> & {
  /**
   * @generated from oneof stroppy.Value.type
   */
  type: {
    /**
     * * Null value 
     *
     * @generated from field: stroppy.Value.NullValue null = 1;
     */
    value: Value_NullValue;
    case: "null";
  } | {
    /**
     * * 32-bit signed integer 
     *
     * @generated from field: int32 int32 = 2;
     */
    value: number;
    case: "int32";
  } | {
    /**
     * * 32-bit unsigned integer 
     *
     * @generated from field: uint32 uint32 = 3;
     */
    value: number;
    case: "uint32";
  } | {
    /**
     * * 64-bit signed integer 
     *
     * @generated from field: int64 int64 = 4;
     */
    value: bigint;
    case: "int64";
  } | {
    /**
     * * 64-bit unsigned integer 
     *
     * @generated from field: uint64 uint64 = 5;
     */
    value: bigint;
    case: "uint64";
  } | {
    /**
     * * 32-bit floating point number 
     *
     * @generated from field: float float = 6;
     */
    value: number;
    case: "float";
  } | {
    /**
     * * 64-bit floating point number 
     *
     * @generated from field: double double = 7;
     */
    value: number;
    case: "double";
  } | {
    /**
     * * UTF-8 encoded string 
     *
     * @generated from field: string string = 8;
     */
    value: string;
    case: "string";
  } | {
    /**
     * * Boolean value 
     *
     * @generated from field: bool bool = 9;
     */
    value: boolean;
    case: "bool";
  } | {
    /**
     * * Arbitrary-precision decimal 
     *
     * @generated from field: stroppy.Decimal decimal = 10;
     */
    value: Decimal;
    case: "decimal";
  } | {
    /**
     * * Universally unique identifier 
     *
     * @generated from field: stroppy.Uuid uuid = 11;
     */
    value: Uuid;
    case: "uuid";
  } | {
    /**
     * * Date and time 
     *
     * @generated from field: stroppy.DateTime datetime = 12;
     */
    value: DateTime;
    case: "datetime";
  } | {
    /**
     * * Nested structure 
     *
     * @generated from field: stroppy.Value.Struct struct = 13;
     */
    value: Value_Struct;
    case: "struct";
  } | {
    /**
     * * List of values 
     *
     * @generated from field: stroppy.Value.List list = 14;
     */
    value: Value_List;
    case: "list";
  } | { case: undefined; value?: undefined };

  /**
   * * Field name (used in structs) 
   *
   * @generated from field: string key = 101;
   */
  key: string;
};

/**
 * *
 * Value is a variant type that can represent different types of values.
 * It's used to represent values that can be of multiple types in a type-safe
 * way.
 *
 * @generated from message stroppy.Value
 */
export type ValueJson = {
  /**
   * * Null value 
   *
   * @generated from field: stroppy.Value.NullValue null = 1;
   */
  null?: Value_NullValueJson;

  /**
   * * 32-bit signed integer 
   *
   * @generated from field: int32 int32 = 2;
   */
  int32?: number;

  /**
   * * 32-bit unsigned integer 
   *
   * @generated from field: uint32 uint32 = 3;
   */
  uint32?: number;

  /**
   * * 64-bit signed integer 
   *
   * @generated from field: int64 int64 = 4;
   */
  int64?: string;

  /**
   * * 64-bit unsigned integer 
   *
   * @generated from field: uint64 uint64 = 5;
   */
  uint64?: string;

  /**
   * * 32-bit floating point number 
   *
   * @generated from field: float float = 6;
   */
  float?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * * 64-bit floating point number 
   *
   * @generated from field: double double = 7;
   */
  double?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * * UTF-8 encoded string 
   *
   * @generated from field: string string = 8;
   */
  string?: string;

  /**
   * * Boolean value 
   *
   * @generated from field: bool bool = 9;
   */
  bool?: boolean;

  /**
   * * Arbitrary-precision decimal 
   *
   * @generated from field: stroppy.Decimal decimal = 10;
   */
  decimal?: DecimalJson;

  /**
   * * Universally unique identifier 
   *
   * @generated from field: stroppy.Uuid uuid = 11;
   */
  uuid?: UuidJson;

  /**
   * * Date and time 
   *
   * @generated from field: stroppy.DateTime datetime = 12;
   */
  datetime?: DateTimeJson;

  /**
   * * Nested structure 
   *
   * @generated from field: stroppy.Value.Struct struct = 13;
   */
  struct?: Value_StructJson;

  /**
   * * List of values 
   *
   * @generated from field: stroppy.Value.List list = 14;
   */
  list?: Value_ListJson;

  /**
   * * Field name (used in structs) 
   *
   * @generated from field: string key = 101;
   */
  key?: string;
};

export type ValueValid = Value;

/**
 * Describes the message stroppy.Value.
 * Use `create(ValueSchema)` to create a new message.
 */
export const ValueSchema: GenMessage<Value, {jsonType: ValueJson, validType: ValueValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 5);

/**
 * @generated from message stroppy.Value.List
 */
export type Value_List = Message<"stroppy.Value.List"> & {
  /**
   * * List of values 
   *
   * @generated from field: repeated stroppy.Value values = 1;
   */
  values: Value[];
};

/**
 * @generated from message stroppy.Value.List
 */
export type Value_ListJson = {
  /**
   * * List of values 
   *
   * @generated from field: repeated stroppy.Value values = 1;
   */
  values?: ValueJson[];
};

export type Value_ListValid = Value_List;

/**
 * Describes the message stroppy.Value.List.
 * Use `create(Value_ListSchema)` to create a new message.
 */
export const Value_ListSchema: GenMessage<Value_List, {jsonType: Value_ListJson, validType: Value_ListValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 5, 0);

/**
 * @generated from message stroppy.Value.Struct
 */
export type Value_Struct = Message<"stroppy.Value.Struct"> & {
  /**
   * * Map of field names to values 
   *
   * @generated from field: repeated stroppy.Value fields = 1;
   */
  fields: Value[];
};

/**
 * @generated from message stroppy.Value.Struct
 */
export type Value_StructJson = {
  /**
   * * Map of field names to values 
   *
   * @generated from field: repeated stroppy.Value fields = 1;
   */
  fields?: ValueJson[];
};

export type Value_StructValid = Value_Struct;

/**
 * Describes the message stroppy.Value.Struct.
 * Use `create(Value_StructSchema)` to create a new message.
 */
export const Value_StructSchema: GenMessage<Value_Struct, {jsonType: Value_StructJson, validType: Value_StructValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 5, 1);

/**
 * @generated from enum stroppy.Value.NullValue
 */
export enum Value_NullValue {
  /**
   * * Null value 
   *
   * @generated from enum value: NULL_VALUE = 0;
   */
  NULL_VALUE = 0,
}

/**
 * @generated from enum stroppy.Value.NullValue
 */
export type Value_NullValueJson = "NULL_VALUE";

/**
 * Describes the enum stroppy.Value.NullValue.
 */
export const Value_NullValueSchema: GenEnum<Value_NullValue, Value_NullValueJson> = /*@__PURE__*/
  enumDesc(file_proto_stroppy_common, 5, 0);

/**
 * *
 * Generation contains configuration for generating test data.
 * It provides rules and constraints for generating various types of data.
 *
 * UTF-8 character ranges for different languages
 * Example: {"en": {{65, 90}, {97, 122}}}
 *
 * @generated from message stroppy.Generation
 */
export type Generation = Message<"stroppy.Generation"> & {
};

/**
 * *
 * Generation contains configuration for generating test data.
 * It provides rules and constraints for generating various types of data.
 *
 * UTF-8 character ranges for different languages
 * Example: {"en": {{65, 90}, {97, 122}}}
 *
 * @generated from message stroppy.Generation
 */
export type GenerationJson = {
};

export type GenerationValid = Generation;

/**
 * Describes the message stroppy.Generation.
 * Use `create(GenerationSchema)` to create a new message.
 */
export const GenerationSchema: GenMessage<Generation, {jsonType: GenerationJson, validType: GenerationValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6);

/**
 * *
 * Alphabet defines character ranges for string generation.
 *
 * @generated from message stroppy.Generation.Alphabet
 */
export type Generation_Alphabet = Message<"stroppy.Generation.Alphabet"> & {
  /**
   * * List of character ranges for this alphabet 
   *
   * @generated from field: repeated stroppy.Generation.Range.UInt32 ranges = 1;
   */
  ranges: Generation_Range_UInt32[];
};

/**
 * *
 * Alphabet defines character ranges for string generation.
 *
 * @generated from message stroppy.Generation.Alphabet
 */
export type Generation_AlphabetJson = {
  /**
   * * List of character ranges for this alphabet 
   *
   * @generated from field: repeated stroppy.Generation.Range.UInt32 ranges = 1;
   */
  ranges?: Generation_Range_UInt32Json[];
};

export type Generation_AlphabetValid = Generation_Alphabet;

/**
 * Describes the message stroppy.Generation.Alphabet.
 * Use `create(Generation_AlphabetSchema)` to create a new message.
 */
export const Generation_AlphabetSchema: GenMessage<Generation_Alphabet, {jsonType: Generation_AlphabetJson, validType: Generation_AlphabetValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 0);

/**
 * *
 * Distribution defines the statistical distribution for value generation.
 *
 * @generated from message stroppy.Generation.Distribution
 */
export type Generation_Distribution = Message<"stroppy.Generation.Distribution"> & {
  /**
   * * Type of distribution to use 
   *
   * @generated from field: stroppy.Generation.Distribution.DistributionType type = 1;
   */
  type: Generation_Distribution_DistributionType;

  /**
   * * Distribution parameter (e.g., standard deviation for normal
   * distribution) 
   *
   * @generated from field: double screw = 2;
   */
  screw: number;
};

/**
 * *
 * Distribution defines the statistical distribution for value generation.
 *
 * @generated from message stroppy.Generation.Distribution
 */
export type Generation_DistributionJson = {
  /**
   * * Type of distribution to use 
   *
   * @generated from field: stroppy.Generation.Distribution.DistributionType type = 1;
   */
  type?: Generation_Distribution_DistributionTypeJson;

  /**
   * * Distribution parameter (e.g., standard deviation for normal
   * distribution) 
   *
   * @generated from field: double screw = 2;
   */
  screw?: number | "NaN" | "Infinity" | "-Infinity";
};

export type Generation_DistributionValid = Generation_Distribution;

/**
 * Describes the message stroppy.Generation.Distribution.
 * Use `create(Generation_DistributionSchema)` to create a new message.
 */
export const Generation_DistributionSchema: GenMessage<Generation_Distribution, {jsonType: Generation_DistributionJson, validType: Generation_DistributionValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 1);

/**
 * @generated from enum stroppy.Generation.Distribution.DistributionType
 */
export enum Generation_Distribution_DistributionType {
  /**
   * * Normal (Gaussian) distribution 
   *
   * @generated from enum value: NORMAL = 0;
   */
  NORMAL = 0,

  /**
   * * Uniform distribution 
   *
   * @generated from enum value: UNIFORM = 1;
   */
  UNIFORM = 1,

  /**
   * * Zipfian distribution 
   *
   * @generated from enum value: ZIPF = 2;
   */
  ZIPF = 2,
}

/**
 * @generated from enum stroppy.Generation.Distribution.DistributionType
 */
export type Generation_Distribution_DistributionTypeJson = "NORMAL" | "UNIFORM" | "ZIPF";

/**
 * Describes the enum stroppy.Generation.Distribution.DistributionType.
 */
export const Generation_Distribution_DistributionTypeSchema: GenEnum<Generation_Distribution_DistributionType, Generation_Distribution_DistributionTypeJson> = /*@__PURE__*/
  enumDesc(file_proto_stroppy_common, 6, 1, 0);

/**
 * *
 * Range defines value constraints for generation.
 *
 * @generated from message stroppy.Generation.Range
 */
export type Generation_Range = Message<"stroppy.Generation.Range"> & {
};

/**
 * *
 * Range defines value constraints for generation.
 *
 * @generated from message stroppy.Generation.Range
 */
export type Generation_RangeJson = {
};

export type Generation_RangeValid = Generation_Range;

/**
 * Describes the message stroppy.Generation.Range.
 * Use `create(Generation_RangeSchema)` to create a new message.
 */
export const Generation_RangeSchema: GenMessage<Generation_Range, {jsonType: Generation_RangeJson, validType: Generation_RangeValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 2);

/**
 * @generated from message stroppy.Generation.Range.Bool
 */
export type Generation_Range_Bool = Message<"stroppy.Generation.Range.Bool"> & {
  /**
   * @generated from field: float ratio = 1;
   */
  ratio: number;
};

/**
 * @generated from message stroppy.Generation.Range.Bool
 */
export type Generation_Range_BoolJson = {
  /**
   * @generated from field: float ratio = 1;
   */
  ratio?: number | "NaN" | "Infinity" | "-Infinity";
};

export type Generation_Range_BoolValid = Generation_Range_Bool;

/**
 * Describes the message stroppy.Generation.Range.Bool.
 * Use `create(Generation_Range_BoolSchema)` to create a new message.
 */
export const Generation_Range_BoolSchema: GenMessage<Generation_Range_Bool, {jsonType: Generation_Range_BoolJson, validType: Generation_Range_BoolValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 2, 0);

/**
 * @generated from message stroppy.Generation.Range.String
 */
export type Generation_Range_String = Message<"stroppy.Generation.Range.String"> & {
  /**
   * * Character set to use for generation 
   *
   * @generated from field: optional stroppy.Generation.Alphabet alphabet = 1;
   */
  alphabet?: Generation_Alphabet;

  /**
   * @generated from field: optional uint64 min_len = 2;
   */
  minLen?: bigint;

  /**
   * @generated from field: uint64 max_len = 3;
   */
  maxLen: bigint;
};

/**
 * @generated from message stroppy.Generation.Range.String
 */
export type Generation_Range_StringJson = {
  /**
   * * Character set to use for generation 
   *
   * @generated from field: optional stroppy.Generation.Alphabet alphabet = 1;
   */
  alphabet?: Generation_AlphabetJson;

  /**
   * @generated from field: optional uint64 min_len = 2;
   */
  minLen?: string;

  /**
   * @generated from field: uint64 max_len = 3;
   */
  maxLen?: string;
};

export type Generation_Range_StringValid = Generation_Range_String;

/**
 * Describes the message stroppy.Generation.Range.String.
 * Use `create(Generation_Range_StringSchema)` to create a new message.
 */
export const Generation_Range_StringSchema: GenMessage<Generation_Range_String, {jsonType: Generation_Range_StringJson, validType: Generation_Range_StringValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 2, 1);

/**
 * * Range for string values that can be parsed into other types 
 *
 * @generated from message stroppy.Generation.Range.AnyString
 */
export type Generation_Range_AnyString = Message<"stroppy.Generation.Range.AnyString"> & {
  /**
   * * Minimum value (inclusive) 
   *
   * @generated from field: string min = 1;
   */
  min: string;

  /**
   * * Maximum value (inclusive) 
   *
   * @generated from field: string max = 2;
   */
  max: string;
};

/**
 * * Range for string values that can be parsed into other types 
 *
 * @generated from message stroppy.Generation.Range.AnyString
 */
export type Generation_Range_AnyStringJson = {
  /**
   * * Minimum value (inclusive) 
   *
   * @generated from field: string min = 1;
   */
  min?: string;

  /**
   * * Maximum value (inclusive) 
   *
   * @generated from field: string max = 2;
   */
  max?: string;
};

export type Generation_Range_AnyStringValid = Generation_Range_AnyString;

/**
 * Describes the message stroppy.Generation.Range.AnyString.
 * Use `create(Generation_Range_AnyStringSchema)` to create a new message.
 */
export const Generation_Range_AnyStringSchema: GenMessage<Generation_Range_AnyString, {jsonType: Generation_Range_AnyStringJson, validType: Generation_Range_AnyStringValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 2, 2);

/**
 * * Range for 32-bit floating point numbers 
 *
 * @generated from message stroppy.Generation.Range.Float
 */
export type Generation_Range_Float = Message<"stroppy.Generation.Range.Float"> & {
  /**
   * * Minimum value (inclusive) 
   *
   * @generated from field: optional float min = 1;
   */
  min?: number;

  /**
   * * Maximum value (inclusive) 
   *
   * @generated from field: float max = 2;
   */
  max: number;
};

/**
 * * Range for 32-bit floating point numbers 
 *
 * @generated from message stroppy.Generation.Range.Float
 */
export type Generation_Range_FloatJson = {
  /**
   * * Minimum value (inclusive) 
   *
   * @generated from field: optional float min = 1;
   */
  min?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * * Maximum value (inclusive) 
   *
   * @generated from field: float max = 2;
   */
  max?: number | "NaN" | "Infinity" | "-Infinity";
};

export type Generation_Range_FloatValid = Generation_Range_Float;

/**
 * Describes the message stroppy.Generation.Range.Float.
 * Use `create(Generation_Range_FloatSchema)` to create a new message.
 */
export const Generation_Range_FloatSchema: GenMessage<Generation_Range_Float, {jsonType: Generation_Range_FloatJson, validType: Generation_Range_FloatValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 2, 3);

/**
 * * Range for 64-bit floating point numbers 
 *
 * @generated from message stroppy.Generation.Range.Double
 */
export type Generation_Range_Double = Message<"stroppy.Generation.Range.Double"> & {
  /**
   * * Minimum value (inclusive) 
   *
   * @generated from field: optional double min = 1;
   */
  min?: number;

  /**
   * * Maximum value (inclusive) 
   *
   * @generated from field: double max = 2;
   */
  max: number;
};

/**
 * * Range for 64-bit floating point numbers 
 *
 * @generated from message stroppy.Generation.Range.Double
 */
export type Generation_Range_DoubleJson = {
  /**
   * * Minimum value (inclusive) 
   *
   * @generated from field: optional double min = 1;
   */
  min?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * * Maximum value (inclusive) 
   *
   * @generated from field: double max = 2;
   */
  max?: number | "NaN" | "Infinity" | "-Infinity";
};

export type Generation_Range_DoubleValid = Generation_Range_Double;

/**
 * Describes the message stroppy.Generation.Range.Double.
 * Use `create(Generation_Range_DoubleSchema)` to create a new message.
 */
export const Generation_Range_DoubleSchema: GenMessage<Generation_Range_Double, {jsonType: Generation_Range_DoubleJson, validType: Generation_Range_DoubleValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 2, 4);

/**
 * * Range for 32-bit signed integers 
 *
 * @generated from message stroppy.Generation.Range.Int32
 */
export type Generation_Range_Int32 = Message<"stroppy.Generation.Range.Int32"> & {
  /**
   * * Minimum value (inclusive) 
   *
   * @generated from field: optional int32 min = 1;
   */
  min?: number;

  /**
   * * Maximum value (inclusive) 
   *
   * @generated from field: int32 max = 2;
   */
  max: number;
};

/**
 * * Range for 32-bit signed integers 
 *
 * @generated from message stroppy.Generation.Range.Int32
 */
export type Generation_Range_Int32Json = {
  /**
   * * Minimum value (inclusive) 
   *
   * @generated from field: optional int32 min = 1;
   */
  min?: number;

  /**
   * * Maximum value (inclusive) 
   *
   * @generated from field: int32 max = 2;
   */
  max?: number;
};

export type Generation_Range_Int32Valid = Generation_Range_Int32;

/**
 * Describes the message stroppy.Generation.Range.Int32.
 * Use `create(Generation_Range_Int32Schema)` to create a new message.
 */
export const Generation_Range_Int32Schema: GenMessage<Generation_Range_Int32, {jsonType: Generation_Range_Int32Json, validType: Generation_Range_Int32Valid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 2, 5);

/**
 * * Range for 64-bit signed integers 
 *
 * @generated from message stroppy.Generation.Range.Int64
 */
export type Generation_Range_Int64 = Message<"stroppy.Generation.Range.Int64"> & {
  /**
   * * Minimum value (inclusive) 
   *
   * @generated from field: optional int64 min = 1;
   */
  min?: bigint;

  /**
   * * Maximum value (inclusive) 
   *
   * @generated from field: int64 max = 2;
   */
  max: bigint;
};

/**
 * * Range for 64-bit signed integers 
 *
 * @generated from message stroppy.Generation.Range.Int64
 */
export type Generation_Range_Int64Json = {
  /**
   * * Minimum value (inclusive) 
   *
   * @generated from field: optional int64 min = 1;
   */
  min?: string;

  /**
   * * Maximum value (inclusive) 
   *
   * @generated from field: int64 max = 2;
   */
  max?: string;
};

export type Generation_Range_Int64Valid = Generation_Range_Int64;

/**
 * Describes the message stroppy.Generation.Range.Int64.
 * Use `create(Generation_Range_Int64Schema)` to create a new message.
 */
export const Generation_Range_Int64Schema: GenMessage<Generation_Range_Int64, {jsonType: Generation_Range_Int64Json, validType: Generation_Range_Int64Valid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 2, 6);

/**
 * * Range for 32-bit unsigned integers 
 *
 * @generated from message stroppy.Generation.Range.UInt32
 */
export type Generation_Range_UInt32 = Message<"stroppy.Generation.Range.UInt32"> & {
  /**
   * * Minimum value (inclusive) 
   *
   * @generated from field: optional uint32 min = 1;
   */
  min?: number;

  /**
   * * Maximum value (inclusive) 
   *
   * @generated from field: uint32 max = 2;
   */
  max: number;
};

/**
 * * Range for 32-bit unsigned integers 
 *
 * @generated from message stroppy.Generation.Range.UInt32
 */
export type Generation_Range_UInt32Json = {
  /**
   * * Minimum value (inclusive) 
   *
   * @generated from field: optional uint32 min = 1;
   */
  min?: number;

  /**
   * * Maximum value (inclusive) 
   *
   * @generated from field: uint32 max = 2;
   */
  max?: number;
};

export type Generation_Range_UInt32Valid = Generation_Range_UInt32;

/**
 * Describes the message stroppy.Generation.Range.UInt32.
 * Use `create(Generation_Range_UInt32Schema)` to create a new message.
 */
export const Generation_Range_UInt32Schema: GenMessage<Generation_Range_UInt32, {jsonType: Generation_Range_UInt32Json, validType: Generation_Range_UInt32Valid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 2, 7);

/**
 * * Range for 64-bit unsigned integers 
 *
 * @generated from message stroppy.Generation.Range.UInt64
 */
export type Generation_Range_UInt64 = Message<"stroppy.Generation.Range.UInt64"> & {
  /**
   * * Minimum value (inclusive) 
   *
   * @generated from field: optional uint64 min = 1;
   */
  min?: bigint;

  /**
   * * Maximum value (inclusive) 
   *
   * @generated from field: uint64 max = 2;
   */
  max: bigint;
};

/**
 * * Range for 64-bit unsigned integers 
 *
 * @generated from message stroppy.Generation.Range.UInt64
 */
export type Generation_Range_UInt64Json = {
  /**
   * * Minimum value (inclusive) 
   *
   * @generated from field: optional uint64 min = 1;
   */
  min?: string;

  /**
   * * Maximum value (inclusive) 
   *
   * @generated from field: uint64 max = 2;
   */
  max?: string;
};

export type Generation_Range_UInt64Valid = Generation_Range_UInt64;

/**
 * Describes the message stroppy.Generation.Range.UInt64.
 * Use `create(Generation_Range_UInt64Schema)` to create a new message.
 */
export const Generation_Range_UInt64Schema: GenMessage<Generation_Range_UInt64, {jsonType: Generation_Range_UInt64Json, validType: Generation_Range_UInt64Valid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 2, 8);

/**
 * * Range for decimal numbers 
 *
 * @generated from message stroppy.Generation.Range.DecimalRange
 */
export type Generation_Range_DecimalRange = Message<"stroppy.Generation.Range.DecimalRange"> & {
  /**
   * @generated from oneof stroppy.Generation.Range.DecimalRange.type
   */
  type: {
    /**
     * * Float-based range 
     *
     * @generated from field: stroppy.Generation.Range.Float float = 2;
     */
    value: Generation_Range_Float;
    case: "float";
  } | {
    /**
     * * Double-based range 
     *
     * @generated from field: stroppy.Generation.Range.Double double = 3;
     */
    value: Generation_Range_Double;
    case: "double";
  } | {
    /**
     * * String-bsed range (supports scientific notation) 
     *
     * @generated from field: stroppy.Generation.Range.AnyString string = 4;
     */
    value: Generation_Range_AnyString;
    case: "string";
  } | { case: undefined; value?: undefined };
};

/**
 * * Range for decimal numbers 
 *
 * @generated from message stroppy.Generation.Range.DecimalRange
 */
export type Generation_Range_DecimalRangeJson = {
  /**
   * * Float-based range 
   *
   * @generated from field: stroppy.Generation.Range.Float float = 2;
   */
  float?: Generation_Range_FloatJson;

  /**
   * * Double-based range 
   *
   * @generated from field: stroppy.Generation.Range.Double double = 3;
   */
  double?: Generation_Range_DoubleJson;

  /**
   * * String-bsed range (supports scientific notation) 
   *
   * @generated from field: stroppy.Generation.Range.AnyString string = 4;
   */
  string?: Generation_Range_AnyStringJson;
};

export type Generation_Range_DecimalRangeValid = Generation_Range_DecimalRange;

/**
 * Describes the message stroppy.Generation.Range.DecimalRange.
 * Use `create(Generation_Range_DecimalRangeSchema)` to create a new message.
 */
export const Generation_Range_DecimalRangeSchema: GenMessage<Generation_Range_DecimalRange, {jsonType: Generation_Range_DecimalRangeJson, validType: Generation_Range_DecimalRangeValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 2, 9);

/**
 * * Range for date/time values 
 *
 * @generated from message stroppy.Generation.Range.DateTime
 */
export type Generation_Range_DateTime = Message<"stroppy.Generation.Range.DateTime"> & {
  /**
   * @generated from oneof stroppy.Generation.Range.DateTime.type
   */
  type: {
    /**
     * * String-based range (ISO 8601 format) 
     *
     * @generated from field: stroppy.Generation.Range.AnyString string = 2;
     */
    value: Generation_Range_AnyString;
    case: "string";
  } | {
    /**
     * * Protocol Buffers timestamp range 
     *
     * @generated from field: stroppy.Generation.Range.DateTime.TimestampPb timestamp_pb = 3;
     */
    value: Generation_Range_DateTime_TimestampPb;
    case: "timestampPb";
  } | {
    /**
     * * Unix timestamp range 
     *
     * @generated from field: stroppy.Generation.Range.DateTime.TimestampUnix timestamp = 4;
     */
    value: Generation_Range_DateTime_TimestampUnix;
    case: "timestamp";
  } | { case: undefined; value?: undefined };
};

/**
 * * Range for date/time values 
 *
 * @generated from message stroppy.Generation.Range.DateTime
 */
export type Generation_Range_DateTimeJson = {
  /**
   * * String-based range (ISO 8601 format) 
   *
   * @generated from field: stroppy.Generation.Range.AnyString string = 2;
   */
  string?: Generation_Range_AnyStringJson;

  /**
   * * Protocol Buffers timestamp range 
   *
   * @generated from field: stroppy.Generation.Range.DateTime.TimestampPb timestamp_pb = 3;
   */
  timestampPb?: Generation_Range_DateTime_TimestampPbJson;

  /**
   * * Unix timestamp range 
   *
   * @generated from field: stroppy.Generation.Range.DateTime.TimestampUnix timestamp = 4;
   */
  timestamp?: Generation_Range_DateTime_TimestampUnixJson;
};

export type Generation_Range_DateTimeValid = Generation_Range_DateTime;

/**
 * Describes the message stroppy.Generation.Range.DateTime.
 * Use `create(Generation_Range_DateTimeSchema)` to create a new message.
 */
export const Generation_Range_DateTimeSchema: GenMessage<Generation_Range_DateTime, {jsonType: Generation_Range_DateTimeJson, validType: Generation_Range_DateTimeValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 2, 10);

/**
 * * Protocol Buffers timestamp range 
 *
 * @generated from message stroppy.Generation.Range.DateTime.TimestampPb
 */
export type Generation_Range_DateTime_TimestampPb = Message<"stroppy.Generation.Range.DateTime.TimestampPb"> & {
  /**
   * * Minimum timestamp (inclusive) 
   *
   * @generated from field: google.protobuf.Timestamp min = 1;
   */
  min?: Timestamp;

  /**
   * * Maximum timestamp (inclusive) 
   *
   * @generated from field: google.protobuf.Timestamp max = 2;
   */
  max?: Timestamp;
};

/**
 * * Protocol Buffers timestamp range 
 *
 * @generated from message stroppy.Generation.Range.DateTime.TimestampPb
 */
export type Generation_Range_DateTime_TimestampPbJson = {
  /**
   * * Minimum timestamp (inclusive) 
   *
   * @generated from field: google.protobuf.Timestamp min = 1;
   */
  min?: TimestampJson;

  /**
   * * Maximum timestamp (inclusive) 
   *
   * @generated from field: google.protobuf.Timestamp max = 2;
   */
  max?: TimestampJson;
};

export type Generation_Range_DateTime_TimestampPbValid = Generation_Range_DateTime_TimestampPb;

/**
 * Describes the message stroppy.Generation.Range.DateTime.TimestampPb.
 * Use `create(Generation_Range_DateTime_TimestampPbSchema)` to create a new message.
 */
export const Generation_Range_DateTime_TimestampPbSchema: GenMessage<Generation_Range_DateTime_TimestampPb, {jsonType: Generation_Range_DateTime_TimestampPbJson, validType: Generation_Range_DateTime_TimestampPbValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 2, 10, 0);

/**
 * * Unix timestamp range 
 *
 * @generated from message stroppy.Generation.Range.DateTime.TimestampUnix
 */
export type Generation_Range_DateTime_TimestampUnix = Message<"stroppy.Generation.Range.DateTime.TimestampUnix"> & {
  /**
   * * Minimum Unix timestamp (inclusive) 
   *
   * @generated from field: uint32 min = 1;
   */
  min: number;

  /**
   * * Maximum Unix timestamp (inclusive) 
   *
   * @generated from field: uint32 max = 2;
   */
  max: number;
};

/**
 * * Unix timestamp range 
 *
 * @generated from message stroppy.Generation.Range.DateTime.TimestampUnix
 */
export type Generation_Range_DateTime_TimestampUnixJson = {
  /**
   * * Minimum Unix timestamp (inclusive) 
   *
   * @generated from field: uint32 min = 1;
   */
  min?: number;

  /**
   * * Maximum Unix timestamp (inclusive) 
   *
   * @generated from field: uint32 max = 2;
   */
  max?: number;
};

export type Generation_Range_DateTime_TimestampUnixValid = Generation_Range_DateTime_TimestampUnix;

/**
 * Describes the message stroppy.Generation.Range.DateTime.TimestampUnix.
 * Use `create(Generation_Range_DateTime_TimestampUnixSchema)` to create a new message.
 */
export const Generation_Range_DateTime_TimestampUnixSchema: GenMessage<Generation_Range_DateTime_TimestampUnix, {jsonType: Generation_Range_DateTime_TimestampUnixJson, validType: Generation_Range_DateTime_TimestampUnixValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 2, 10, 1);

/**
 * *
 * Rule defines generation rules for a specific data type.
 *
 * @generated from message stroppy.Generation.Rule
 */
export type Generation_Rule = Message<"stroppy.Generation.Rule"> & {
  /**
   * *
   * Exactly one variant must be set; tooling treats this as mutually
   * exclusive. Prefer ranges for variability and consts for fixed values.
   *
   * @generated from oneof stroppy.Generation.Rule.kind
   */
  kind: {
    /**
     * * Signed 32‑bit integer range (inclusive). Example: 1..100 for
     * IDs. 
     *
     * @generated from field: stroppy.Generation.Range.Int32 int32_range = 1;
     */
    value: Generation_Range_Int32;
    case: "int32Range";
  } | {
    /**
     * * Signed 64‑bit integer range for large counters or timestamps. 
     *
     * @generated from field: stroppy.Generation.Range.Int64 int64_range = 2;
     */
    value: Generation_Range_Int64;
    case: "int64Range";
  } | {
    /**
     * * Unsigned 32‑bit integer range; use for sizes/indices. 
     *
     * @generated from field: stroppy.Generation.Range.UInt32 uint32_range = 3;
     */
    value: Generation_Range_UInt32;
    case: "uint32Range";
  } | {
    /**
     * * Unsigned 64‑bit integer range; use for large sizes. 
     *
     * @generated from field: stroppy.Generation.Range.UInt64 uint64_range = 4;
     */
    value: Generation_Range_UInt64;
    case: "uint64Range";
  } | {
    /**
     * * 32‑bit float bounds; beware precision for currency. 
     *
     * @generated from field: stroppy.Generation.Range.Float float_range = 5;
     */
    value: Generation_Range_Float;
    case: "floatRange";
  } | {
    /**
     * * 64‑bit float bounds for high‑precision numeric data. 
     *
     * @generated from field: stroppy.Generation.Range.Double double_range = 6;
     */
    value: Generation_Range_Double;
    case: "doubleRange";
  } | {
    /**
     * * Arbitrary‑precision decimal bounds for money/ratios. 
     *
     * @generated from field: stroppy.Generation.Range.DecimalRange decimal_range = 7;
     */
    value: Generation_Range_DecimalRange;
    case: "decimalRange";
  } | {
    /**
     * * String constraints (length, alphabet). 
     *
     * @generated from field: stroppy.Generation.Range.String string_range = 8;
     */
    value: Generation_Range_String;
    case: "stringRange";
  } | {
    /**
     * * Boolean constraints (e.g., force true/false). 
     *
     * @generated from field: stroppy.Generation.Range.Bool bool_range = 9;
     */
    value: Generation_Range_Bool;
    case: "boolRange";
  } | {
    /**
     * * Date/time window (e.g., not before/after). 
     *
     * @generated from field: stroppy.Generation.Range.DateTime datetime_range = 10;
     */
    value: Generation_Range_DateTime;
    case: "datetimeRange";
  } | {
    /**
     * * Fixed 32‑bit integer value. 
     *
     * @generated from field: int32 int32_const = 11;
     */
    value: number;
    case: "int32Const";
  } | {
    /**
     * * Fixed 64‑bit integer value. 
     *
     * @generated from field: int64 int64_const = 12;
     */
    value: bigint;
    case: "int64Const";
  } | {
    /**
     * * Fixed unsigned 32‑bit integer value. 
     *
     * @generated from field: uint32 uint32_const = 13;
     */
    value: number;
    case: "uint32Const";
  } | {
    /**
     * * Fixed unsigned 64‑bit integer value. 
     *
     * @generated from field: uint64 uint64_const = 14;
     */
    value: bigint;
    case: "uint64Const";
  } | {
    /**
     * * Fixed 32‑bit float value. 
     *
     * @generated from field: float float_const = 15;
     */
    value: number;
    case: "floatConst";
  } | {
    /**
     * * Fixed 64‑bit float value. 
     *
     * @generated from field: double double_const = 16;
     */
    value: number;
    case: "doubleConst";
  } | {
    /**
     * * Fixed decimal value. 
     *
     * @generated from field: stroppy.Decimal decimal_const = 17;
     */
    value: Decimal;
    case: "decimalConst";
  } | {
    /**
     * * Fixed string value. 
     *
     * @generated from field: string string_const = 18;
     */
    value: string;
    case: "stringConst";
  } | {
    /**
     * * Fixed boolean value. 
     *
     * @generated from field: bool bool_const = 19;
     */
    value: boolean;
    case: "boolConst";
  } | {
    /**
     * * Fixed date/time value. 
     *
     * @generated from field: stroppy.DateTime datetime_const = 20;
     */
    value: DateTime;
    case: "datetimeConst";
  } | { case: undefined; value?: undefined };

  /**
   * * Shape of randomness; Normal by default 
   *
   * @generated from field: optional stroppy.Generation.Distribution distribution = 30;
   */
  distribution?: Generation_Distribution;

  /**
   * * Percentage of nulls to inject [0..100]; 0 by default
   *
   * @generated from field: optional uint32 null_percentage = 31;
   */
  nullPercentage?: number;

  /**
   * * Enforce uniqueness across generated values;
   * Linear sequence for ranges 
   *
   * @generated from field: optional bool unique = 32;
   */
  unique?: boolean;
};

/**
 * *
 * Rule defines generation rules for a specific data type.
 *
 * @generated from message stroppy.Generation.Rule
 */
export type Generation_RuleJson = {
  /**
   * * Signed 32‑bit integer range (inclusive). Example: 1..100 for
   * IDs. 
   *
   * @generated from field: stroppy.Generation.Range.Int32 int32_range = 1;
   */
  int32Range?: Generation_Range_Int32Json;

  /**
   * * Signed 64‑bit integer range for large counters or timestamps. 
   *
   * @generated from field: stroppy.Generation.Range.Int64 int64_range = 2;
   */
  int64Range?: Generation_Range_Int64Json;

  /**
   * * Unsigned 32‑bit integer range; use for sizes/indices. 
   *
   * @generated from field: stroppy.Generation.Range.UInt32 uint32_range = 3;
   */
  uint32Range?: Generation_Range_UInt32Json;

  /**
   * * Unsigned 64‑bit integer range; use for large sizes. 
   *
   * @generated from field: stroppy.Generation.Range.UInt64 uint64_range = 4;
   */
  uint64Range?: Generation_Range_UInt64Json;

  /**
   * * 32‑bit float bounds; beware precision for currency. 
   *
   * @generated from field: stroppy.Generation.Range.Float float_range = 5;
   */
  floatRange?: Generation_Range_FloatJson;

  /**
   * * 64‑bit float bounds for high‑precision numeric data. 
   *
   * @generated from field: stroppy.Generation.Range.Double double_range = 6;
   */
  doubleRange?: Generation_Range_DoubleJson;

  /**
   * * Arbitrary‑precision decimal bounds for money/ratios. 
   *
   * @generated from field: stroppy.Generation.Range.DecimalRange decimal_range = 7;
   */
  decimalRange?: Generation_Range_DecimalRangeJson;

  /**
   * * String constraints (length, alphabet). 
   *
   * @generated from field: stroppy.Generation.Range.String string_range = 8;
   */
  stringRange?: Generation_Range_StringJson;

  /**
   * * Boolean constraints (e.g., force true/false). 
   *
   * @generated from field: stroppy.Generation.Range.Bool bool_range = 9;
   */
  boolRange?: Generation_Range_BoolJson;

  /**
   * * Date/time window (e.g., not before/after). 
   *
   * @generated from field: stroppy.Generation.Range.DateTime datetime_range = 10;
   */
  datetimeRange?: Generation_Range_DateTimeJson;

  /**
   * * Fixed 32‑bit integer value. 
   *
   * @generated from field: int32 int32_const = 11;
   */
  int32Const?: number;

  /**
   * * Fixed 64‑bit integer value. 
   *
   * @generated from field: int64 int64_const = 12;
   */
  int64Const?: string;

  /**
   * * Fixed unsigned 32‑bit integer value. 
   *
   * @generated from field: uint32 uint32_const = 13;
   */
  uint32Const?: number;

  /**
   * * Fixed unsigned 64‑bit integer value. 
   *
   * @generated from field: uint64 uint64_const = 14;
   */
  uint64Const?: string;

  /**
   * * Fixed 32‑bit float value. 
   *
   * @generated from field: float float_const = 15;
   */
  floatConst?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * * Fixed 64‑bit float value. 
   *
   * @generated from field: double double_const = 16;
   */
  doubleConst?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * * Fixed decimal value. 
   *
   * @generated from field: stroppy.Decimal decimal_const = 17;
   */
  decimalConst?: DecimalJson;

  /**
   * * Fixed string value. 
   *
   * @generated from field: string string_const = 18;
   */
  stringConst?: string;

  /**
   * * Fixed boolean value. 
   *
   * @generated from field: bool bool_const = 19;
   */
  boolConst?: boolean;

  /**
   * * Fixed date/time value. 
   *
   * @generated from field: stroppy.DateTime datetime_const = 20;
   */
  datetimeConst?: DateTimeJson;

  /**
   * * Shape of randomness; Normal by default 
   *
   * @generated from field: optional stroppy.Generation.Distribution distribution = 30;
   */
  distribution?: Generation_DistributionJson;

  /**
   * * Percentage of nulls to inject [0..100]; 0 by default
   *
   * @generated from field: optional uint32 null_percentage = 31;
   */
  nullPercentage?: number;

  /**
   * * Enforce uniqueness across generated values;
   * Linear sequence for ranges 
   *
   * @generated from field: optional bool unique = 32;
   */
  unique?: boolean;
};

export type Generation_RuleValid = Generation_Rule;

/**
 * Describes the message stroppy.Generation.Rule.
 * Use `create(Generation_RuleSchema)` to create a new message.
 */
export const Generation_RuleSchema: GenMessage<Generation_Rule, {jsonType: Generation_RuleJson, validType: Generation_RuleValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_common, 6, 3);

