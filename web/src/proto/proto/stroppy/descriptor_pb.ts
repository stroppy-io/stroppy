// @generated by protoc-gen-es v2.10.0 with parameter "json_types=true,valid_types=legacy_required+protovalidate_required,target=ts,import_extension=ts"
// @generated from file proto/stroppy/descriptor.proto (package stroppy, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Generation_Rule, Generation_RuleJson, Value_Struct, Value_StructJson } from "./common_pb.ts";
import { file_proto_stroppy_common } from "./common_pb.ts";
import { file_validate_validate } from "../../validate/validate_pb.ts";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file proto/stroppy/descriptor.proto.
 */
export const file_proto_stroppy_descriptor: GenFile = /*@__PURE__*/
  fileDesc("Ch5wcm90by9zdHJvcHB5L2Rlc2NyaXB0b3IucHJvdG8SB3N0cm9wcHkiqQEKD0luZGV4RGVzY3JpcHRvchIVCgRuYW1lGAEgASgJQgf6QgRyAhABEiAKB2NvbHVtbnMYAiADKAlCD/pCDJIBCRgBIgWKAQIQARIMCgR0eXBlGAMgASgJEg4KBnVuaXF1ZRgEIAEoCBIvCgtkYl9zcGVjaWZpYxgFIAEoCzIVLnN0cm9wcHkuVmFsdWUuU3RydWN0SACIAQFCDgoMX2RiX3NwZWNpZmljItoBChBDb2x1bW5EZXNjcmlwdG9yEhUKBG5hbWUYASABKAlCB/pCBHICEAESGQoIc3FsX3R5cGUYAiABKAlCB/pCBHICEAESFQoIbnVsbGFibGUYAyABKAhIAIgBARIYCgtwcmltYXJ5X2tleRgEIAEoCEgBiAEBEhMKBnVuaXF1ZRgFIAEoCEgCiAEBEhcKCmNvbnN0cmFpbnQYBiABKAlIA4gBAUILCglfbnVsbGFibGVCDgoMX3ByaW1hcnlfa2V5QgkKB191bmlxdWVCDQoLX2NvbnN0cmFpbnQi/QEKD1RhYmxlRGVzY3JpcHRvchIVCgRuYW1lGAEgASgJQgf6QgRyAhABEj4KDXRhYmxlX2luZGV4ZXMYAyADKAsyGC5zdHJvcHB5LkluZGV4RGVzY3JpcHRvckIN+kIKkgEHIgWKAQIQARIXCgpjb25zdHJhaW50GAUgASgJSACIAQESLwoLZGJfc3BlY2lmaWMYBiABKAsyFS5zdHJvcHB5LlZhbHVlLlN0cnVjdEgBiAEBEioKB2NvbHVtbnMYZCADKAsyGS5zdHJvcHB5LkNvbHVtbkRlc2NyaXB0b3JCDQoLX2NvbnN0cmFpbnRCDgoMX2RiX3NwZWNpZmljIuUBChBJbnNlcnREZXNjcmlwdG9yEhUKBG5hbWUYASABKAlCB/pCBHICEAESGwoKdGFibGVfbmFtZRgCIAEoCUIH+kIEcgIQARIqCgZtZXRob2QYAyABKA4yFS5zdHJvcHB5Lkluc2VydE1ldGhvZEgAiAEBEjwKBnBhcmFtcxgEIAMoCzIdLnN0cm9wcHkuUXVlcnlQYXJhbURlc2NyaXB0b3JCDfpCCpIBByIFigECEAESKAoGZ3JvdXBzGAUgAygLMhguc3Ryb3BweS5RdWVyeVBhcmFtR3JvdXBCCQoHX21ldGhvZCLZAQoUUXVlcnlQYXJhbURlc2NyaXB0b3ISFQoEbmFtZRgBIAEoCUIH+kIEcgIQARIaCg1yZXBsYWNlX3JlZ2V4GAIgASgJSACIAQESOwoPZ2VuZXJhdGlvbl9ydWxlGAMgASgLMhguc3Ryb3BweS5HZW5lcmF0aW9uLlJ1bGVCCPpCBYoBAhABEi8KC2RiX3NwZWNpZmljGAQgASgLMhUuc3Ryb3BweS5WYWx1ZS5TdHJ1Y3RIAYgBAUIQCg5fcmVwbGFjZV9yZWdleEIOCgxfZGJfc3BlY2lmaWMiTgoPUXVlcnlQYXJhbUdyb3VwEgwKBG5hbWUYASABKAkSLQoGcGFyYW1zGAIgAygLMh0uc3Ryb3BweS5RdWVyeVBhcmFtRGVzY3JpcHRvciLnAQoPUXVlcnlEZXNjcmlwdG9yEhUKBG5hbWUYASABKAlCB/pCBHICEAESFAoDc3FsGAIgASgJQgf6QgRyAhABEjwKBnBhcmFtcxgDIAMoCzIdLnN0cm9wcHkuUXVlcnlQYXJhbURlc2NyaXB0b3JCDfpCCpIBByIFigECEAESKAoGZ3JvdXBzGAQgAygLMhguc3Ryb3BweS5RdWVyeVBhcmFtR3JvdXASLwoLZGJfc3BlY2lmaWMYBSABKAsyFS5zdHJvcHB5LlZhbHVlLlN0cnVjdEgAiAEBQg4KDF9kYl9zcGVjaWZpYyLfAQoVVHJhbnNhY3Rpb25EZXNjcmlwdG9yEhUKBG5hbWUYASABKAlCB/pCBHICEAESMgoPaXNvbGF0aW9uX2xldmVsGAIgASgOMhkuc3Ryb3BweS5UeElzb2xhdGlvbkxldmVsEjoKB3F1ZXJpZXMYAyADKAsyGC5zdHJvcHB5LlF1ZXJ5RGVzY3JpcHRvckIP+kIMkgEJCAEiBYoBAhABEi8KC2RiX3NwZWNpZmljGAUgASgLMhUuc3Ryb3BweS5WYWx1ZS5TdHJ1Y3RIAIgBAUIOCgxfZGJfc3BlY2lmaWMi3gEKDlVuaXREZXNjcmlwdG9yEjAKDGNyZWF0ZV90YWJsZRgBIAEoCzIYLnN0cm9wcHkuVGFibGVEZXNjcmlwdG9ySAASKwoGaW5zZXJ0GAUgASgLMhkuc3Ryb3BweS5JbnNlcnREZXNjcmlwdG9ySAASKQoFcXVlcnkYAiABKAsyGC5zdHJvcHB5LlF1ZXJ5RGVzY3JpcHRvckgAEjUKC3RyYW5zYWN0aW9uGAQgASgLMh4uc3Ryb3BweS5UcmFuc2FjdGlvbkRlc2NyaXB0b3JIAEILCgR0eXBlEgP4QgEiXQoWV29ya2xvYWRVbml0RGVzY3JpcHRvchIrCgpkZXNjcmlwdG9yGAYgASgLMhcuc3Ryb3BweS5Vbml0RGVzY3JpcHRvchIWCgVjb3VudBgFIAEoBEIH+kIEMgIgACKKAQoSV29ya2xvYWREZXNjcmlwdG9yEhUKBG5hbWUYASABKAlCB/pCBHICEAESEgoFYXN5bmMYAiABKAhIAIgBARI/CgV1bml0cxgDIAMoCzIfLnN0cm9wcHkuV29ya2xvYWRVbml0RGVzY3JpcHRvckIP+kIMkgEJCAEiBYoBAhABQggKBl9hc3luYyJtChNCZW5jaG1hcmtEZXNjcmlwdG9yEhUKBG5hbWUYASABKAlCB/pCBHICEAESPwoJd29ya2xvYWRzGGQgAygLMhsuc3Ryb3BweS5Xb3JrbG9hZERlc2NyaXB0b3JCD/pCDJIBCQgBIgWKAQIQASouCgxJbnNlcnRNZXRob2QSDwoLUExBSU5fUVVFUlkQABINCglDT1BZX0ZST00QASp0ChBUeElzb2xhdGlvbkxldmVsEg8KC1VOU1BFQ0lGSUVEEAASFAoQUkVBRF9VTkNPTU1JVFRFRBABEhIKDlJFQURfQ09NTUlUVEVEEAISEwoPUkVQRUFUQUJMRV9SRUFEEAMSEAoMU0VSSUFMSVpBQkxFEARCOFo2Z2l0aHViLmNvbS9zdHJvcHB5LWlvL3N0cm9wcHkvcGtnL2NvbW1vbi9wcm90by9zdHJvcHB5YgZwcm90bzM", [file_proto_stroppy_common, file_validate_validate]);

/**
 * *
 * IndexDescriptor defines the structure of a database index.
 *
 * @generated from message stroppy.IndexDescriptor
 */
export type IndexDescriptor = Message<"stroppy.IndexDescriptor"> & {
  /**
   * * Name of the index 
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * * List of column names that are part of this index 
   *
   * @generated from field: repeated string columns = 2;
   */
  columns: string[];

  /**
   * * Type of index (e.g., BTREE, HASH, etc.) 
   *
   * @generated from field: string type = 3;
   */
  type: string;

  /**
   * * Whether this is a unique index 
   *
   * @generated from field: bool unique = 4;
   */
  unique: boolean;

  /**
   * * Database-specific index properties 
   *
   * @generated from field: optional stroppy.Value.Struct db_specific = 5;
   */
  dbSpecific?: Value_Struct;
};

/**
 * *
 * IndexDescriptor defines the structure of a database index.
 *
 * @generated from message stroppy.IndexDescriptor
 */
export type IndexDescriptorJson = {
  /**
   * * Name of the index 
   *
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * * List of column names that are part of this index 
   *
   * @generated from field: repeated string columns = 2;
   */
  columns?: string[];

  /**
   * * Type of index (e.g., BTREE, HASH, etc.) 
   *
   * @generated from field: string type = 3;
   */
  type?: string;

  /**
   * * Whether this is a unique index 
   *
   * @generated from field: bool unique = 4;
   */
  unique?: boolean;

  /**
   * * Database-specific index properties 
   *
   * @generated from field: optional stroppy.Value.Struct db_specific = 5;
   */
  dbSpecific?: Value_StructJson;
};

export type IndexDescriptorValid = IndexDescriptor;

/**
 * Describes the message stroppy.IndexDescriptor.
 * Use `create(IndexDescriptorSchema)` to create a new message.
 */
export const IndexDescriptorSchema: GenMessage<IndexDescriptor, {jsonType: IndexDescriptorJson, validType: IndexDescriptorValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_descriptor, 0);

/**
 * *
 * ColumnDescriptor defines the structure of a database column.
 *
 * @generated from message stroppy.ColumnDescriptor
 */
export type ColumnDescriptor = Message<"stroppy.ColumnDescriptor"> & {
  /**
   * * Name of the column 
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * * SQL data type of the column 
   *
   * @generated from field: string sql_type = 2;
   */
  sqlType: string;

  /**
   * * Whether the column can be NULL 
   *
   * @generated from field: optional bool nullable = 3;
   */
  nullable?: boolean;

  /**
   * *
   * Whether the column is part of the primary key.
   * Multiple primary keys creates composite primary key.
   *
   * @generated from field: optional bool primary_key = 4;
   */
  primaryKey?: boolean;

  /**
   * * Whether the column has a UNIQUE constraint 
   *
   * @generated from field: optional bool unique = 5;
   */
  unique?: boolean;

  /**
   * * SQL constraint definition for the column in free form 
   *
   * @generated from field: optional string constraint = 6;
   */
  constraint?: string;
};

/**
 * *
 * ColumnDescriptor defines the structure of a database column.
 *
 * @generated from message stroppy.ColumnDescriptor
 */
export type ColumnDescriptorJson = {
  /**
   * * Name of the column 
   *
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * * SQL data type of the column 
   *
   * @generated from field: string sql_type = 2;
   */
  sqlType?: string;

  /**
   * * Whether the column can be NULL 
   *
   * @generated from field: optional bool nullable = 3;
   */
  nullable?: boolean;

  /**
   * *
   * Whether the column is part of the primary key.
   * Multiple primary keys creates composite primary key.
   *
   * @generated from field: optional bool primary_key = 4;
   */
  primaryKey?: boolean;

  /**
   * * Whether the column has a UNIQUE constraint 
   *
   * @generated from field: optional bool unique = 5;
   */
  unique?: boolean;

  /**
   * * SQL constraint definition for the column in free form 
   *
   * @generated from field: optional string constraint = 6;
   */
  constraint?: string;
};

export type ColumnDescriptorValid = ColumnDescriptor;

/**
 * Describes the message stroppy.ColumnDescriptor.
 * Use `create(ColumnDescriptorSchema)` to create a new message.
 */
export const ColumnDescriptorSchema: GenMessage<ColumnDescriptor, {jsonType: ColumnDescriptorJson, validType: ColumnDescriptorValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_descriptor, 1);

/**
 * *
 * TableDescriptor defines the structure of a database table.
 *
 * @generated from message stroppy.TableDescriptor
 */
export type TableDescriptor = Message<"stroppy.TableDescriptor"> & {
  /**
   * * Name of the table 
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * * List of indexes defined on this table 
   *
   * @generated from field: repeated stroppy.IndexDescriptor table_indexes = 3;
   */
  tableIndexes: IndexDescriptor[];

  /**
   * * Table-level constraints 
   *
   * @generated from field: optional string constraint = 5;
   */
  constraint?: string;

  /**
   * * Database-specific table properties 
   *
   * @generated from field: optional stroppy.Value.Struct db_specific = 6;
   */
  dbSpecific?: Value_Struct;

  /**
   * * Columns defined in this table 
   *
   * @generated from field: repeated stroppy.ColumnDescriptor columns = 100;
   */
  columns: ColumnDescriptor[];
};

/**
 * *
 * TableDescriptor defines the structure of a database table.
 *
 * @generated from message stroppy.TableDescriptor
 */
export type TableDescriptorJson = {
  /**
   * * Name of the table 
   *
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * * List of indexes defined on this table 
   *
   * @generated from field: repeated stroppy.IndexDescriptor table_indexes = 3;
   */
  tableIndexes?: IndexDescriptorJson[];

  /**
   * * Table-level constraints 
   *
   * @generated from field: optional string constraint = 5;
   */
  constraint?: string;

  /**
   * * Database-specific table properties 
   *
   * @generated from field: optional stroppy.Value.Struct db_specific = 6;
   */
  dbSpecific?: Value_StructJson;

  /**
   * * Columns defined in this table 
   *
   * @generated from field: repeated stroppy.ColumnDescriptor columns = 100;
   */
  columns?: ColumnDescriptorJson[];
};

export type TableDescriptorValid = TableDescriptor;

/**
 * Describes the message stroppy.TableDescriptor.
 * Use `create(TableDescriptorSchema)` to create a new message.
 */
export const TableDescriptorSchema: GenMessage<TableDescriptor, {jsonType: TableDescriptorJson, validType: TableDescriptorValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_descriptor, 2);

/**
 * *
 * InsertDescription defines data to fill database.
 *
 * @generated from message stroppy.InsertDescriptor
 */
export type InsertDescriptor = Message<"stroppy.InsertDescriptor"> & {
  /**
   * * Name of the Insert query 
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * * Which table to insert the values 
   *
   * @generated from field: string table_name = 2;
   */
  tableName: string;

  /**
   * * Allows to use a percise method of data insertion 
   *
   * @generated from field: optional stroppy.InsertMethod method = 3;
   */
  method?: InsertMethod;

  /**
   * *
   * Parameters used in the insert.
   * Names threated as db columns names, regexp is ignored.
   *
   * @generated from field: repeated stroppy.QueryParamDescriptor params = 4;
   */
  params: QueryParamDescriptor[];

  /**
   * * Groups of the columns 
   *
   * @generated from field: repeated stroppy.QueryParamGroup groups = 5;
   */
  groups: QueryParamGroup[];
};

/**
 * *
 * InsertDescription defines data to fill database.
 *
 * @generated from message stroppy.InsertDescriptor
 */
export type InsertDescriptorJson = {
  /**
   * * Name of the Insert query 
   *
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * * Which table to insert the values 
   *
   * @generated from field: string table_name = 2;
   */
  tableName?: string;

  /**
   * * Allows to use a percise method of data insertion 
   *
   * @generated from field: optional stroppy.InsertMethod method = 3;
   */
  method?: InsertMethodJson;

  /**
   * *
   * Parameters used in the insert.
   * Names threated as db columns names, regexp is ignored.
   *
   * @generated from field: repeated stroppy.QueryParamDescriptor params = 4;
   */
  params?: QueryParamDescriptorJson[];

  /**
   * * Groups of the columns 
   *
   * @generated from field: repeated stroppy.QueryParamGroup groups = 5;
   */
  groups?: QueryParamGroupJson[];
};

export type InsertDescriptorValid = InsertDescriptor;

/**
 * Describes the message stroppy.InsertDescriptor.
 * Use `create(InsertDescriptorSchema)` to create a new message.
 */
export const InsertDescriptorSchema: GenMessage<InsertDescriptor, {jsonType: InsertDescriptorJson, validType: InsertDescriptorValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_descriptor, 3);

/**
 * *
 * QueryParamDescriptor defines a parameter that can be used in a query.
 *
 * @generated from message stroppy.QueryParamDescriptor
 */
export type QueryParamDescriptor = Message<"stroppy.QueryParamDescriptor"> & {
  /**
   * * Name of the parameter 
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * * Regular expression pattern to replace with the parameter value default
   * is "${<param_name>}" 
   *
   * @generated from field: optional string replace_regex = 2;
   */
  replaceRegex?: string;

  /**
   * * Rule for generating parameter values 
   *
   * @generated from field: stroppy.Generation.Rule generation_rule = 3;
   */
  generationRule?: Generation_Rule;

  /**
   * * Database-specific parameter properties 
   *
   * @generated from field: optional stroppy.Value.Struct db_specific = 4;
   */
  dbSpecific?: Value_Struct;
};

/**
 * *
 * QueryParamDescriptor defines a parameter that can be used in a query.
 *
 * @generated from message stroppy.QueryParamDescriptor
 */
export type QueryParamDescriptorJson = {
  /**
   * * Name of the parameter 
   *
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * * Regular expression pattern to replace with the parameter value default
   * is "${<param_name>}" 
   *
   * @generated from field: optional string replace_regex = 2;
   */
  replaceRegex?: string;

  /**
   * * Rule for generating parameter values 
   *
   * @generated from field: stroppy.Generation.Rule generation_rule = 3;
   */
  generationRule?: Generation_RuleJson;

  /**
   * * Database-specific parameter properties 
   *
   * @generated from field: optional stroppy.Value.Struct db_specific = 4;
   */
  dbSpecific?: Value_StructJson;
};

export type QueryParamDescriptorValid = QueryParamDescriptor;

/**
 * Describes the message stroppy.QueryParamDescriptor.
 * Use `create(QueryParamDescriptorSchema)` to create a new message.
 */
export const QueryParamDescriptorSchema: GenMessage<QueryParamDescriptor, {jsonType: QueryParamDescriptorJson, validType: QueryParamDescriptorValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_descriptor, 4);

/**
 * *
 * QueryParamGroup defines a group of dependent parameters.
 * New values generated in Carthesian product manner.
 * It's useful to define composite primary keys.
 * Every evaluation step only one param changes.
 *
 * @generated from message stroppy.QueryParamGroup
 */
export type QueryParamGroup = Message<"stroppy.QueryParamGroup"> & {
  /**
   * * Group name 
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * * Grouped dependent parameters 
   *
   * @generated from field: repeated stroppy.QueryParamDescriptor params = 2;
   */
  params: QueryParamDescriptor[];
};

/**
 * *
 * QueryParamGroup defines a group of dependent parameters.
 * New values generated in Carthesian product manner.
 * It's useful to define composite primary keys.
 * Every evaluation step only one param changes.
 *
 * @generated from message stroppy.QueryParamGroup
 */
export type QueryParamGroupJson = {
  /**
   * * Group name 
   *
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * * Grouped dependent parameters 
   *
   * @generated from field: repeated stroppy.QueryParamDescriptor params = 2;
   */
  params?: QueryParamDescriptorJson[];
};

export type QueryParamGroupValid = QueryParamGroup;

/**
 * Describes the message stroppy.QueryParamGroup.
 * Use `create(QueryParamGroupSchema)` to create a new message.
 */
export const QueryParamGroupSchema: GenMessage<QueryParamGroup, {jsonType: QueryParamGroupJson, validType: QueryParamGroupValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_descriptor, 5);

/**
 * *
 * QueryDescriptor defines a database query with its parameters and execution
 * count.
 *
 * @generated from message stroppy.QueryDescriptor
 */
export type QueryDescriptor = Message<"stroppy.QueryDescriptor"> & {
  /**
   * * Name of the query 
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * * SQL query text 
   *
   * @generated from field: string sql = 2;
   */
  sql: string;

  /**
   * * Parameters used in the query 
   *
   * @generated from field: repeated stroppy.QueryParamDescriptor params = 3;
   */
  params: QueryParamDescriptor[];

  /**
   * * Groups of the parameters 
   *
   * @generated from field: repeated stroppy.QueryParamGroup groups = 4;
   */
  groups: QueryParamGroup[];

  /**
   * * Database-specific query properties 
   *
   * @generated from field: optional stroppy.Value.Struct db_specific = 5;
   */
  dbSpecific?: Value_Struct;
};

/**
 * *
 * QueryDescriptor defines a database query with its parameters and execution
 * count.
 *
 * @generated from message stroppy.QueryDescriptor
 */
export type QueryDescriptorJson = {
  /**
   * * Name of the query 
   *
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * * SQL query text 
   *
   * @generated from field: string sql = 2;
   */
  sql?: string;

  /**
   * * Parameters used in the query 
   *
   * @generated from field: repeated stroppy.QueryParamDescriptor params = 3;
   */
  params?: QueryParamDescriptorJson[];

  /**
   * * Groups of the parameters 
   *
   * @generated from field: repeated stroppy.QueryParamGroup groups = 4;
   */
  groups?: QueryParamGroupJson[];

  /**
   * * Database-specific query properties 
   *
   * @generated from field: optional stroppy.Value.Struct db_specific = 5;
   */
  dbSpecific?: Value_StructJson;
};

export type QueryDescriptorValid = QueryDescriptor;

/**
 * Describes the message stroppy.QueryDescriptor.
 * Use `create(QueryDescriptorSchema)` to create a new message.
 */
export const QueryDescriptorSchema: GenMessage<QueryDescriptor, {jsonType: QueryDescriptorJson, validType: QueryDescriptorValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_descriptor, 6);

/**
 * *
 * TransactionDescriptor defines a database transaction with its queries and
 * execution count.
 *
 * @generated from message stroppy.TransactionDescriptor
 */
export type TransactionDescriptor = Message<"stroppy.TransactionDescriptor"> & {
  /**
   * * Name of the transaction 
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * * Transaction isolation level 
   *
   * @generated from field: stroppy.TxIsolationLevel isolation_level = 2;
   */
  isolationLevel: TxIsolationLevel;

  /**
   * * List of queries to execute in this transaction 
   *
   * @generated from field: repeated stroppy.QueryDescriptor queries = 3;
   */
  queries: QueryDescriptor[];

  /**
   * * Database-specific transaction properties 
   *
   * @generated from field: optional stroppy.Value.Struct db_specific = 5;
   */
  dbSpecific?: Value_Struct;
};

/**
 * *
 * TransactionDescriptor defines a database transaction with its queries and
 * execution count.
 *
 * @generated from message stroppy.TransactionDescriptor
 */
export type TransactionDescriptorJson = {
  /**
   * * Name of the transaction 
   *
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * * Transaction isolation level 
   *
   * @generated from field: stroppy.TxIsolationLevel isolation_level = 2;
   */
  isolationLevel?: TxIsolationLevelJson;

  /**
   * * List of queries to execute in this transaction 
   *
   * @generated from field: repeated stroppy.QueryDescriptor queries = 3;
   */
  queries?: QueryDescriptorJson[];

  /**
   * * Database-specific transaction properties 
   *
   * @generated from field: optional stroppy.Value.Struct db_specific = 5;
   */
  dbSpecific?: Value_StructJson;
};

export type TransactionDescriptorValid = TransactionDescriptor;

/**
 * Describes the message stroppy.TransactionDescriptor.
 * Use `create(TransactionDescriptorSchema)` to create a new message.
 */
export const TransactionDescriptorSchema: GenMessage<TransactionDescriptor, {jsonType: TransactionDescriptorJson, validType: TransactionDescriptorValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_descriptor, 7);

/**
 * *
 * UnitDescriptor represents a single workload.
 * It can be a table creation operation, a query execution operation, or a
 * transaction execution operation.
 *
 * @generated from message stroppy.UnitDescriptor
 */
export type UnitDescriptor = Message<"stroppy.UnitDescriptor"> & {
  /**
   * @generated from oneof stroppy.UnitDescriptor.type
   */
  type: {
    /**
     * * Table creation operation 
     *
     * @generated from field: stroppy.TableDescriptor create_table = 1;
     */
    value: TableDescriptor;
    case: "createTable";
  } | {
    /**
     * * Data insertion operation 
     *
     * @generated from field: stroppy.InsertDescriptor insert = 5;
     */
    value: InsertDescriptor;
    case: "insert";
  } | {
    /**
     * * Query execution operation 
     *
     * @generated from field: stroppy.QueryDescriptor query = 2;
     */
    value: QueryDescriptor;
    case: "query";
  } | {
    /**
     * * Transaction execution operation 
     *
     * @generated from field: stroppy.TransactionDescriptor transaction = 4;
     */
    value: TransactionDescriptor;
    case: "transaction";
  } | { case: undefined; value?: undefined };
};

/**
 * *
 * UnitDescriptor represents a single workload.
 * It can be a table creation operation, a query execution operation, or a
 * transaction execution operation.
 *
 * @generated from message stroppy.UnitDescriptor
 */
export type UnitDescriptorJson = {
  /**
   * * Table creation operation 
   *
   * @generated from field: stroppy.TableDescriptor create_table = 1;
   */
  createTable?: TableDescriptorJson;

  /**
   * * Data insertion operation 
   *
   * @generated from field: stroppy.InsertDescriptor insert = 5;
   */
  insert?: InsertDescriptorJson;

  /**
   * * Query execution operation 
   *
   * @generated from field: stroppy.QueryDescriptor query = 2;
   */
  query?: QueryDescriptorJson;

  /**
   * * Transaction execution operation 
   *
   * @generated from field: stroppy.TransactionDescriptor transaction = 4;
   */
  transaction?: TransactionDescriptorJson;
};

export type UnitDescriptorValid = UnitDescriptor;

/**
 * Describes the message stroppy.UnitDescriptor.
 * Use `create(UnitDescriptorSchema)` to create a new message.
 */
export const UnitDescriptorSchema: GenMessage<UnitDescriptor, {jsonType: UnitDescriptorJson, validType: UnitDescriptorValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_descriptor, 8);

/**
 * *
 * WorkloadUnitDescriptor represents a single unit of work.
 * It can be a table creation operation, a query execution operation, or a
 * transaction execution operation.
 *
 * @generated from message stroppy.WorkloadUnitDescriptor
 */
export type WorkloadUnitDescriptor = Message<"stroppy.WorkloadUnitDescriptor"> & {
  /**
   * @generated from field: stroppy.UnitDescriptor descriptor = 6;
   */
  descriptor?: UnitDescriptor;

  /**
   * * Number of times to execute this unit 
   *
   * @generated from field: uint64 count = 5;
   */
  count: bigint;
};

/**
 * *
 * WorkloadUnitDescriptor represents a single unit of work.
 * It can be a table creation operation, a query execution operation, or a
 * transaction execution operation.
 *
 * @generated from message stroppy.WorkloadUnitDescriptor
 */
export type WorkloadUnitDescriptorJson = {
  /**
   * @generated from field: stroppy.UnitDescriptor descriptor = 6;
   */
  descriptor?: UnitDescriptorJson;

  /**
   * * Number of times to execute this unit 
   *
   * @generated from field: uint64 count = 5;
   */
  count?: string;
};

export type WorkloadUnitDescriptorValid = WorkloadUnitDescriptor;

/**
 * Describes the message stroppy.WorkloadUnitDescriptor.
 * Use `create(WorkloadUnitDescriptorSchema)` to create a new message.
 */
export const WorkloadUnitDescriptorSchema: GenMessage<WorkloadUnitDescriptor, {jsonType: WorkloadUnitDescriptorJson, validType: WorkloadUnitDescriptorValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_descriptor, 9);

/**
 * *
 * WorkloadDescriptor represents a logical step in a benchmark.
 * It contains a list of operations to perform in this step.
 *
 * @generated from message stroppy.WorkloadDescriptor
 */
export type WorkloadDescriptor = Message<"stroppy.WorkloadDescriptor"> & {
  /**
   * * Name of the step 
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * * Whether to execute all operations in this workload asynchronously 
   *
   * @generated from field: optional bool async = 2;
   */
  async?: boolean;

  /**
   * * List of operations to perform in this step 
   *
   * @generated from field: repeated stroppy.WorkloadUnitDescriptor units = 3;
   */
  units: WorkloadUnitDescriptor[];
};

/**
 * *
 * WorkloadDescriptor represents a logical step in a benchmark.
 * It contains a list of operations to perform in this step.
 *
 * @generated from message stroppy.WorkloadDescriptor
 */
export type WorkloadDescriptorJson = {
  /**
   * * Name of the step 
   *
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * * Whether to execute all operations in this workload asynchronously 
   *
   * @generated from field: optional bool async = 2;
   */
  async?: boolean;

  /**
   * * List of operations to perform in this step 
   *
   * @generated from field: repeated stroppy.WorkloadUnitDescriptor units = 3;
   */
  units?: WorkloadUnitDescriptorJson[];
};

export type WorkloadDescriptorValid = WorkloadDescriptor;

/**
 * Describes the message stroppy.WorkloadDescriptor.
 * Use `create(WorkloadDescriptorSchema)` to create a new message.
 */
export const WorkloadDescriptorSchema: GenMessage<WorkloadDescriptor, {jsonType: WorkloadDescriptorJson, validType: WorkloadDescriptorValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_descriptor, 10);

/**
 * *
 * BenchmarkDescriptor defines a complete benchmark consisting of multiple
 * steps.
 *
 * @generated from message stroppy.BenchmarkDescriptor
 */
export type BenchmarkDescriptor = Message<"stroppy.BenchmarkDescriptor"> & {
  /**
   * * Name of the benchmark 
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * * List of steps to execute in the benchmark 
   *
   * @generated from field: repeated stroppy.WorkloadDescriptor workloads = 100;
   */
  workloads: WorkloadDescriptor[];
};

/**
 * *
 * BenchmarkDescriptor defines a complete benchmark consisting of multiple
 * steps.
 *
 * @generated from message stroppy.BenchmarkDescriptor
 */
export type BenchmarkDescriptorJson = {
  /**
   * * Name of the benchmark 
   *
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * * List of steps to execute in the benchmark 
   *
   * @generated from field: repeated stroppy.WorkloadDescriptor workloads = 100;
   */
  workloads?: WorkloadDescriptorJson[];
};

export type BenchmarkDescriptorValid = BenchmarkDescriptor;

/**
 * Describes the message stroppy.BenchmarkDescriptor.
 * Use `create(BenchmarkDescriptorSchema)` to create a new message.
 */
export const BenchmarkDescriptorSchema: GenMessage<BenchmarkDescriptor, {jsonType: BenchmarkDescriptorJson, validType: BenchmarkDescriptorValid}> = /*@__PURE__*/
  messageDesc(file_proto_stroppy_descriptor, 11);

/**
 * * Data insertion method 
 *
 * @generated from enum stroppy.InsertMethod
 */
export enum InsertMethod {
  /**
   * @generated from enum value: PLAIN_QUERY = 0;
   */
  PLAIN_QUERY = 0,

  /**
   * @generated from enum value: COPY_FROM = 1;
   */
  COPY_FROM = 1,
}

/**
 * * Data insertion method 
 *
 * @generated from enum stroppy.InsertMethod
 */
export type InsertMethodJson = "PLAIN_QUERY" | "COPY_FROM";

/**
 * Describes the enum stroppy.InsertMethod.
 */
export const InsertMethodSchema: GenEnum<InsertMethod, InsertMethodJson> = /*@__PURE__*/
  enumDesc(file_proto_stroppy_descriptor, 0);

/**
 * *
 * TransactionIsolationLevel defines the isolation level for a database
 * transaction.
 *
 * @generated from enum stroppy.TxIsolationLevel
 */
export enum TxIsolationLevel {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: READ_UNCOMMITTED = 1;
   */
  READ_UNCOMMITTED = 1,

  /**
   * @generated from enum value: READ_COMMITTED = 2;
   */
  READ_COMMITTED = 2,

  /**
   * @generated from enum value: REPEATABLE_READ = 3;
   */
  REPEATABLE_READ = 3,

  /**
   * @generated from enum value: SERIALIZABLE = 4;
   */
  SERIALIZABLE = 4,
}

/**
 * *
 * TransactionIsolationLevel defines the isolation level for a database
 * transaction.
 *
 * @generated from enum stroppy.TxIsolationLevel
 */
export type TxIsolationLevelJson = "UNSPECIFIED" | "READ_UNCOMMITTED" | "READ_COMMITTED" | "REPEATABLE_READ" | "SERIALIZABLE";

/**
 * Describes the enum stroppy.TxIsolationLevel.
 */
export const TxIsolationLevelSchema: GenEnum<TxIsolationLevel, TxIsolationLevelJson> = /*@__PURE__*/
  enumDesc(file_proto_stroppy_descriptor, 1);

