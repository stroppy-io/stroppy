# specify this to override name of all resources
fullnameOverride: ""
## image details
image:
  repository: ghcr.io/naukograd-software/stroppy-cloud-pannel
  pullPolicy: Always
  ## image tag serves as the app version
  ## Use specific tag from CI/CD pipeline
  tag: ""

configmap:
  configMapValues: [ ]
  #   KEY1: "value1"
  #   KEY2: "value2"
  yamlFiles: [ ]

  jsonFiles: [ ]
  #   example.json: |
  #     {
  #       "keyX": "valueX",
  #       "keyY": "valueY"
  #     }
  #   second_example.json: |
  #     {
  #       "keyZ": "valueX",
  #       "keyD": "valueY"
  #     }
  customFiles: [ ]
  #   example.custom: |
  #     customKey1: customValue1
  #     customKey2: customValue2

env: { }
#  KEY: VALUE
#     or
#  KEY:
#    secretKeyRef:
#      name: secret_name
#      key: key_from_secret
#      or
#  KEY:
#    configMapKeyRef:
#      name: secret_name
#      key: key_from_secret

## existing K8s secret name containing auth details
imagePullSecrets:
  - name: komeet-ghcr-credentials
  # - name: my-private-repo-secret
# number of app replicas for deployment

stroppy-cloud-pannel:
  replicaCount: 1

  secrets:
    stroppy-cloud-pannel-env:
      DB_HOST: postgres
      DB_PORT: "5432"
      DB_USER: stroppy
      DB_PASSWORD: stroppy
      DB_NAME: stroppy
      DB_SSLMODE: disable
      PORT: "8080"
      JWT_SECRET: change-this-in-production
    # Дополнительные секреты можно добавить здесь:
    # SECRET_NAME:
    #   KEY1: VALUE1
    #   KEY2: VALUE2

  secretsAnnotations: { }

  env:
    # Переменные окружения из секрета
    DB_HOST:
      secretKeyRef:
        name: stroppy-cloud-pannel-env
        key: DB_HOST
    DB_PORT:
      secretKeyRef:
        name: stroppy-cloud-pannel-env
        key: DB_PORT
    DB_USER:
      secretKeyRef:
        name: stroppy-cloud-pannel-env
        key: DB_USER
    DB_PASSWORD:
      secretKeyRef:
        name: stroppy-cloud-pannel-env
        key: DB_PASSWORD
    DB_NAME:
      secretKeyRef:
        name: stroppy-cloud-pannel-env
        key: DB_NAME
    DB_SSLMODE:
      secretKeyRef:
        name: stroppy-cloud-pannel-env
        key: DB_SSLMODE
    PORT:
      secretKeyRef:
        name: stroppy-cloud-pannel-env
        key: PORT
    JWT_SECRET:
      secretKeyRef:
        name: stroppy-cloud-pannel-env
        key: JWT_SECRET
    # Дополнительные переменные можно добавить здесь:
    #  KEY: VALUE
    #     or
    #   KEY:
    #     secretKeyRef:
    #       name: secret_name
    #       key: key_from_secret

  ## command to execute
  command: ""
  # command: ["/bin/sh"]

  ## args for the command
  args: ""
  # args: ["-c", "while true; do echo hello; sleep 10;done"]

  ## application's service account configs
  serviceAccount:
    ## Specifies whether a service account should be created
    create: false
    ## Annotations to add to the service account
    annotations: { }
    # eks.amazonaws.com/role-arn: arn:aws:iam::ACCOUNT_ID:role/role-name
    ## The name of the service account to use.
    ## If not set and create is true, a name is generated using the fullname template
    name: ""

  ## annotations to be added to pods
  podAnnotations: { }

  ## labels to be added to pods
  extraPodLabels: { }
  # app.kubernetes.io/page-team: frontend
  # app.kubernetes.io/criticality: low

  ## annotations to be added to service (ex: loadbalancer)
  serviceAnnotations: { }
    ## Ingress is preferred to loadbalancer, unless non-http(s) or non default http(s) ports needs to be exposed
    # external-dns.alpha.kubernetes.io/hostname: <pp_name>.<env>.drsmile.co
  # service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: ip
  # service.beta.kubernetes.io/aws-load-balancer-type: external
  # service.beta.kubernetes.io/aws-load-balancer-scheme: <internal (access via VPN only)|internet-facing>

  ## labels to be added to Service
  extraServiceLabels: { }
  # app.kubernetes.io/page-team: frontend
  # app.kubernetes.io/criticality: low


  ## pod level security context
  podSecurityContext: { }
  # fsGroup: 2000

  ## container level security context
  securityContext: { }
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
  # runAsUser: 1000
  # runAsGroup: 3000
  # fsGroup: 2000

  ## define persistent volume for the app
  persistentVolume:
    ## whether to create a PVC
    enabled: false
    size: 8Gi
    ## existing storage class
    # storageClass: "gp2"

  ## list of volumes to be added to the pod
  extraVolumes: [ ]
  # - name: my-storage
  #   emptyDir: {}

  ## list of volume mounts to be added to the pod
  extraVolumeMounts: [ ]
  # - name: my-storage
  #   mountPath: /data

  ## extra containers
  extraContainers: [ ]
    # - name: nginx
    #   image: "docker.io/nginx"
    #   tag: "latest"
    #   imagePullPolicy: IfNotPresent
    #   ports:
    #     - name: nginx_http
    #       containerPort: 80
    #       protocol: TCP
    #   ## Env is similar as global env
    #   env: {}
    #   #  KEY:
    #   #    configMapKeyRef:
    #   #      name: secret_name 
    #   #      key: key_from_secret
    #   resources:
    #     requests:
    #       cpu: 50m
    #       memory: 128Mi
    #     # limits:
    #     #   cpu: 100m
    #     #   memory: 128Mi 

    #   # Probe's for extra container
    #   livenessProbe: {}

    #   readinessProbe: {}
    #   # examples of probe you can take from section of main app

    #   ## list of volume mounts to be added to the extraContainer     
  #   extraVolumeMounts: []
  #     # - name: my-storage
  #     #   mountPath: /data


  ## ports on which the app container is listening on
  ## format: APP_PORT_NAME: APP_PORT_NUMBER
  appPorts:
    grpc: 50050
    http: 8080

  ## how the app is accesible within the cluster
  service:
    enabled: true
    type: ClusterIP

    ## if enabled, ALL "appPorts" will be used in Service
    useAllAppPorts: false

    ## when "useAllAppPorts: false", only ports below will be exposed via Service
    ## format: APP_PORT_NAME: SERVICE_PORT_NUMBER
    #
    ## this means the fraffic will flow like this:
    ##    service.ports.<SERVICE_PORT_NUMBER> -> appPorts.<APP_PORT_NUMBER>
    ##    matching by APP_PORT_NAME
    ports:
      grpc: 50050
      http: 8080

  ## exposing the app to outside of the cluster
  ingress:
    enabled: false
    ## ingress class name
    className: ""
    annotations: { }
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    hosts:
      - host: my-awesome-example.local
        paths:
          - path: /
            pathType: ImplementationSpecific
            ## portName must match one of the service's ports
            portName: http
    tls: [ ]
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  livenessProbe:
    httpGet:
      path: /healthz/liveness
      port: http
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

  readinessProbe:
    httpGet:
      path: /healthz/readiness
      port: http
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3

    ## examples of probes:

    ## HTTP request
    #
    # httpGet:
    #   path: /healthz
    #   port: 8080
    #   httpHeaders:
    #   - name: Custom-Header
    #     value: Awesome
    # initialDelaySeconds: 15
    # periodSeconds: 3

    ## command request
    #
    # exec:
    #   command:
    #   - cat
    #   - /tmp/ready
    # initialDelaySeconds: 3
    # periodSeconds: 5

    ## TCP socket request
    #
    # tcpSocket:
  #   port: 8080
  # initialDelaySeconds: 5
  # periodSeconds: 10

  resources:
    requests:
      cpu: 50m
      memory: 128Mi
    # limits:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 5
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  nodeSelector: { }

  tolerations: [ ]

  affinity: { }